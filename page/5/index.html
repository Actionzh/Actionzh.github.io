<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Actionzh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Actionzh">
<meta property="og:url" content="http://yoursite.com/page/5/index.html">
<meta property="og:site_name" content="Actionzh">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Actionzh">
  
    <link rel="alternate" href="/atom.xml" title="Actionzh" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Actionzh</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/technology">Technology</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-flow(active)" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/29/flow(active)/" class="article-date">
  <time datetime="2019-03-29T02:01:16.000Z" itemprop="datePublished">2019-03-29</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/29/flow(active)/">flow(active)流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>active相关旅程。<br>CustomerJourneyController.activate方法：<br>1先保存customerJourney<br>2然后调用customerJourneyService.activate(triggerId)：<br>2.1查询出customerJourney，根据uimodel转换出LinkedJourney，<br>2.2再根据LinkedJourney得到相关得properties加入customerJourney<br>2.3根据customerJourney和linkedJourney进行deploy<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">deploy(</span><br><span class="line">[1].bpmnGenerator.generateBPMN-&gt;converter出bpmnModel，[2].bpmnGenerator.getTriggerCondition(triggerNode)-&gt;根据triggerNode得到comditionstring，此处根据根节点workflowEvent得出beanname 从而得到对应得TriggerConditionGenerator接口得具体实现，核心方法generateInternal主要用来返回生成的condition字符串。(所有得trigger generator在此处使用)</span><br><span class="line">[3].customerJourney设置得到的bpmn，triggerType，workflowEvent，condition</span><br><span class="line">[4].根据customerJourneyname和bpmn进行deploy并返回ProcessDefinitionId,并设置到customerJourney中</span><br><span class="line">[5].customerJourney中每个properties都设置processDedfId和triggerId)</span><br></pre></td></tr></table></figure></p>
<p>2.4 deploy结束返回customerJourney，设置ACTIVE状态，并更新表数据<br>2.5最后保存所有properties节点信息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/29/flow(active)/" data-id="cjyvglqpb000ts4urohib6mxt" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-32403" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/32403/" class="article-date">
  <time datetime="2019-03-24T14:54:16.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/32403/">subList</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="List接口中定义："><a href="#List接口中定义：" class="headerlink" title="List接口中定义："></a>List接口中定义：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;E&gt; subList(int fromIndex, int toIndex);</span><br></pre></td></tr></table></figure>
<h3 id="英文注释："><a href="#英文注释：" class="headerlink" title="英文注释："></a>英文注释：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Returns a view of the portion of this list between the specified fromIndex, inclusive, and toIndex, exclusive. (If fromIndex and toIndex are equal, the </span><br><span class="line">returned list is empty.) The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa. </span><br><span class="line">The returned list supports all of the optional list operations supported by this list.</span><br><span class="line"></span><br><span class="line">This method eliminates the need for explicit range operations (of the sort that commonly exist for arrays). Any operation that expects a list can be used as a </span><br><span class="line">range operation by passing a subList view instead of a whole list. For example, the following idiom removes a range of elements from a list: </span><br><span class="line">      list.subList(from, to).clear();</span><br><span class="line"></span><br><span class="line">Similar idioms may be constructed for indexOf and lastIndexOf, and all of the algorithms in the Collections class can be applied to a subList.</span><br><span class="line">The semantics of the list returned by this method become undefined if the backing list (i.e., this list) is structurally modified in any way other than via </span><br><span class="line">the returned list. (Structural modifications are those that change the size of this list, or otherwise perturb it in such a fashion that iterations in </span><br><span class="line">progress may yield incorrect results.)</span><br></pre></td></tr></table></figure>
<p>根据注释得知：</p>
<p>1，该方法返回的是父list的一个视图，从fromIndex（包含），到toIndex（不包含）。fromIndex=toIndex 表示子list为空</p>
<p>2，父子list做的非结构性修改（non-structural changes）都会影响到彼此：所谓的“非结构性修改”，是指不涉及到list的大小改变的修改。相反，结构性修改，指改变了list大小的修改。</p>
<p>3，对于结构性修改，子list的所有操作都会反映到父list上。但父list的修改将会导致返回的子list失效。</p>
<p>4，tips：如何删除list中的某段数据：</p>
<p>list.subList(from, to).clear();</p>
<h3 id="示例代码："><a href="#示例代码：" class="headerlink" title="示例代码："></a>示例代码：</h3><p>来自<a href="http://www.cnblogs.com/weknow619/p/6251065.html" target="_blank" rel="noopener">【Java每日一题】20170105</a>，就是看到这个题目才让我知道list的这个方法我没有接触过</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">package ques; import java.util.ArrayList; import java.util.List; public class Ques0105 &#123; public static void main(String[] args) &#123;  </span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;String&gt;();  </span><br><span class="line">        list.add(&quot;a&quot;); // 使用构造器创建一个包含list的列表list1 </span><br><span class="line">        List&lt;String&gt; list1 = new ArrayList&lt;String&gt;(list); // 使用subList生成与list相同的列表list2 </span><br><span class="line">        List&lt;String&gt; list2 = list.subList(0, list.size());  </span><br><span class="line">        list2.add(&quot;b&quot;);  </span><br><span class="line"></span><br><span class="line">        System.out.println(list.equals(list1));  </span><br><span class="line">        System.out.println(list.equals(list2));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回结果如下：<br><img src="/2019/03/24/32403/1.png" alt="1"></p>
<p>可以发现，list2为list的子list，当list2发生结构性修改（list2.add(“b”)）后，list也发生相应改变，所以返回结果为false和true</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/32403/" data-id="cjyvglqp2000js4urspdafxmn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-41601" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/41601/" class="article-date">
  <time datetime="2019-03-24T14:54:16.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/41601/">当 forEach 需要索引</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java8：当-forEach-需要索引"><a href="#Java8：当-forEach-需要索引" class="headerlink" title="Java8：当 forEach 需要索引"></a>Java8：当 forEach 需要索引</h1><p>在 <a href="https://www.jianshu.com/p/5db0cf79d2d5" target="_blank" rel="noopener">上一篇文章</a> 中，我们讨论了如何使用 Java8 中 <code>Map</code> 添加的新方法 <code>computeIfAbsent</code> 来统计集合中每个元素出现的所有位置，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; list.size(); i++) &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(list.get(i), k -&gt; new ArrayList&lt;&gt;(1)).add(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至少有两点需要探讨：<br>1、如果 <em>list</em> 不是基于数组的（即不是 <code>RandomAccess</code> 的），而是基于链表的，那么 <code>list.get(int index)</code> 方法的效率就值得思考了；<br>2、既然都有了 Lambda（即当前平台为 Java8），我们为什么还要一次次去写传统的 for 循环呢？</p>
<p>在 Java8 中，为 <code>Iterable</code> 接口添加了默认的 <code>forEach</code> 方法：</p>
<p><img src="/2019/03/24/41601/1.png" alt="1"></p>
<p>很好理解，遍历当前 <code>Iterable</code> 中所有的元素，使用每个元素作为参数调用一次 <em>action</em>。而 <code>Collection</code> 接口继承了 <code>Iterable</code> 接口，所以所有的继承自 <code>Collection</code> 的集合类都可以直接调用 <code>forEach</code> 方法。比如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    list.forEach(str -&gt; System.out.print(str + &quot;  &quot;));</span><br><span class="line"></span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2019/03/24/41601/2.png" alt="2"></p>
<p>forEach 运行示例</p>
<p>那如果我们在遍历的时候需要使用到元素的索引呢（类似 <code>getElementPositions</code> 方法那样）？<br>很可惜，Java8 的 <code>Iterable</code> 并没有提供一个带索引的 <code>forEach</code> 方法。不过自己动手，丰衣足食 —— 让我们自己写一个带索引的 <code>forEach</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">import java.util.Objects;</span><br><span class="line">import java.util.function.BiConsumer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Iterable 的工具类</span><br><span class="line"> */</span><br><span class="line">public class Iterables &#123;</span><br><span class="line"></span><br><span class="line">    public static &lt;E&gt; void forEach(</span><br><span class="line">            Iterable&lt;? extends E&gt; elements, BiConsumer&lt;Integer, ? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(elements);</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line"></span><br><span class="line">        int index = 0;</span><br><span class="line">        for (E element : elements) &#123;</span><br><span class="line">            action.accept(index++, element);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该 <code>forEach</code> 方法第一个参数为要遍历的 <code>Iterable</code>，第二个参数为 <code>BiConsumer</code>。<code>BiConsumer</code> 的输入参数第一个即索引，第二个为元素。</p>
<p>我们测试下这个 <code>forEach</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; System.out.println(index + &quot; -&gt; &quot; + str));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：<br><img src="/2019/03/24/41601/3.png" alt="3"></p>
<p>结果和预期的一致。</p>
<p>现在我们使用 <code>Iterables.forEach</code> 改写 <code>getElementPositions</code> 方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public static Map&lt;String, List&lt;Integer&gt;&gt; getElementPositions(List&lt;String&gt; list) &#123;</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; positionsMap = new HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    Iterables.forEach(list, (index, str) -&gt; &#123;</span><br><span class="line">        positionsMap.computeIfAbsent(str, k -&gt; new ArrayList&lt;&gt;(1)).add(index);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    return positionsMap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    List&lt;String&gt; list = Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;b&quot;, &quot;c&quot;, &quot;c&quot;, &quot;c&quot;, &quot;d&quot;, &quot;d&quot;, &quot;d&quot;, &quot;f&quot;, &quot;f&quot;, &quot;g&quot;);</span><br><span class="line"></span><br><span class="line">    System.out.println(&quot;使用 computeIfAbsent 和 Iterable.forEach：&quot;);</span><br><span class="line">    Map&lt;String, List&lt;Integer&gt;&gt; elementPositions = getElementPositions(list);</span><br><span class="line">    System.out.println(elementPositions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果和原来一致：<br><img src="/2019/03/24/41601/4.png" alt="4"></p>
<p>使用 computeIfAbsent 和 Iterable.forEach 的运行结果</p>
<p>真的不明白这么简单且实用的方法，Java8 为什么不在 <code>Iterable</code> 中提供一个默认实现（此处应有黑人问号）。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/41601/" data-id="cjyvglqp4000ls4urrde1nwa2" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-32402" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/32402/" class="article-date">
  <time datetime="2019-03-24T14:51:59.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/32402/">通配符和边界</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p><code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>是Java泛型中的<strong>“通配符（Wildcards）”</strong>和<strong>“边界（Bounds）”</strong>的概念。</p>
<ul>
<li>&lt;? extends T&gt;：是指 <strong>“上界通配符（Upper Bounds Wildcards）”</strong></li>
<li>&lt;? super T&gt;：是指 <strong>“下界通配符（Lower Bounds Wildcards）”</strong></li>
</ul>
<h3 id="为什么要用通配符和边界？"><a href="#为什么要用通配符和边界？" class="headerlink" title="为什么要用通配符和边界？"></a>为什么要用通配符和边界？</h3><p>使用泛型的过程中，经常出现一种很别扭的情况。比如按照题主的例子，我们有Fruit类，和它的派生类Apple类。</p>
<p>class Fruit {} class Apple extends Fruit {}</p>
<p>然后有一个最简单的容器：Plate类。盘子里可以放一个泛型的“东西”。我们可以对这个东西做最简单的“放”和“取”的动作：set( )和get( )方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Plate&lt;T&gt;&#123; </span><br><span class="line">private T item;</span><br><span class="line"> public Plate(T t)&#123;item=t;&#125; </span><br><span class="line"> public void set(T t)&#123;item=t;&#125; </span><br><span class="line"> public T get()&#123;return item;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我定义一个“水果盘子”，逻辑上水果盘子当然可以装苹果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple());</span><br></pre></td></tr></table></figure>
<p>但实际上Java编译器不允许这个操作。会报错，“装苹果的盘子”无法转换成“装水果的盘子”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">error: incompatible types: Plate&lt;Apple&gt; cannot be converted to Plate&lt;Fruit&gt;</span><br></pre></td></tr></table></figure>
<p>所以我的尴尬症就犯了。实际上，编译器脑袋里认定的逻辑是这样的：</p>
<ul>
<li><strong>苹果 IS-A 水果</strong></li>
<li><strong>装苹果的盘子 NOT-IS-A 装水果的盘子</strong></li>
</ul>
<p>所以，就算容器里装的东西之间有继承关系，但容器之间是没有继承关系的。所以我们不可以把Plate的引用传递给Plate。</p>
<p>为了让泛型用起来更舒服，Sun的大脑袋们就想出了<code>&lt;? extends T&gt;</code>和<code>&lt;? super T&gt;</code>的办法，来让”水果盘子“和”苹果盘子“之间发生关系。</p>
<h3 id="什么是上界？"><a href="#什么是上界？" class="headerlink" title="什么是上界？"></a>什么是上界？</h3><p>下面代码就是“上界通配符（Upper Bounds Wildcards）”：</p>
<p>Plate&lt;？ extends Fruit&gt;</p>
<p>翻译成人话就是：一个能放水果以及一切是水果派生类的盘子。再直白点就是：啥水果都能放的盘子。这和我们人类的逻辑就比较接近了。<code>Plate&lt;？ extends Fruit&gt;</code>和<code>Plate&lt;Apple&gt;</code>最大的区别就是：<code>Plate&lt;？ extends Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>以及<code>Plate&lt;Apple&gt;</code>的基类。直接的好处就是，我们可以用“苹果盘子”给“水果盘子”赋值了。</p>
<p>Plate&lt;? extends Fruit&gt; p=new Plate<apple>(new Apple());</apple></p>
<p>如果把Fruit和Apple的例子再扩展一下，食物分成水果和肉类，水果有苹果和香蕉，肉类有猪肉和牛肉，苹果还有两种青苹果和红苹果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//Lev 1</span><br><span class="line">class Food&#123;&#125; </span><br><span class="line">//Lev 2</span><br><span class="line">class Fruit extends Food&#123;&#125; </span><br><span class="line">class Meat extends Food&#123;&#125; </span><br><span class="line">//Lev 3</span><br><span class="line">class Apple extends Fruit&#123;&#125; </span><br><span class="line">class Banana extends Fruit&#123;&#125; </span><br><span class="line">class Pork extends Meat&#123;&#125; </span><br><span class="line">class Beef extends Meat&#123;&#125; </span><br><span class="line">//Lev 4</span><br><span class="line">class RedApple extends Apple&#123;&#125; </span><br><span class="line">class GreenApple extends Apple&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在这个体系中，下界通配符 <code>Plate&lt;？ extends Fruit&gt;</code> 覆盖下图中蓝色的区域。</p>
<p><img src="/2019/03/24/32402/1.png" alt="1"></p>
<h3 id="什么是下界？"><a href="#什么是下界？" class="headerlink" title="什么是下界？"></a>什么是下界？</h3><p>相对应的，“下界通配符（Lower Bounds Wildcards）”：</p>
<p>Plate&lt;？ super Fruit&gt;</p>
<p>表达的就是相反的概念：一个能放水果以及一切是水果基类的盘子。<code>Plate&lt;？ super Fruit&gt;</code>是<code>Plate&lt;Fruit&gt;</code>的基类，但不是<code>Plate&lt;Apple&gt;</code>的基类。对应刚才那个例子，<code>Plate&lt;？ super Fruit&gt;</code>覆盖下图中红色的区域。</p>
<p><img src="/2019/03/24/32402/2.png" alt="2"></p>
<h3 id="上下界通配符的副作用"><a href="#上下界通配符的副作用" class="headerlink" title="上下界通配符的副作用"></a>上下界通配符的副作用</h3><p>边界让Java不同泛型之间的转换更容易了。但不要忘记，这样的转换也有一定的副作用。那就是容器的部分功能可能失效。</p>
<p>还是以刚才的Plate为例。我们可以对盘子做两件事，往盘子里set()新东西，以及从盘子里get()东西。</p>
<p>class Plate<t>{ private T item; public Plate(T t){item=t;} public void set(T t){item=t;} public T get(){return item;}<br>}</t></p>
<h4 id="上界-lt-extends-T-gt-不能往里存，只能往外取"><a href="#上界-lt-extends-T-gt-不能往里存，只能往外取" class="headerlink" title="上界&lt;? extends T&gt;不能往里存，只能往外取"></a>上界&lt;? extends T&gt;不能往里存，只能往外取</h4><p><strong>&lt;? extends Fruit&gt;会使往盘子里放东西的set( )方法失效。但取东西get( )方法还有效。比如下面例子里两个set()方法，插入Apple和Fruit都报错。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? extends Fruit&gt; p=new Plate&lt;Apple&gt;(new Apple()); //不能存入任何元素</span><br><span class="line">p.set(new Fruit());    //Error</span><br><span class="line">p.set(new Apple());    //Error //读取出来的东西只能存放在Fruit或它的基类里。</span><br><span class="line">Fruit newFruit1=p.get();</span><br><span class="line">Object newFruit2=p.get();</span><br><span class="line">Apple newFruit3=p.get();    //Error</span><br></pre></td></tr></table></figure>
<p>原因是编译器只知道容器内是Fruit或者它的派生类，但具体是什么类型不知道。可能是Fruit？可能是Apple？也可能是Banana，RedApple，GreenApple？编译器在看到后面用Plate赋值以后，盘子里没有被标上有“苹果”。而是标上一个占位符：CAP#1，来表示捕获一个Fruit或Fruit的子类，具体是什么类不知道，代号CAP#1。然后无论是想往里插入Apple或者Meat或者Fruit编译器都不知道能不能和这个CAP#1匹配，所以就都不允许。</p>
<p>所以通配符&lt;?&gt;和类型参数的区别就在于，对编译器来说所有的T都代表同一种类型。比如下面这个泛型方法里，三个T都指代同一个类型，要么都是String，要么都是Integer。</p>
<p>public <t> List<t> fill(T… t);</t></t></p>
<p>但通配符<code>&lt;?&gt;</code>没有这种约束，<code>Plate&lt;?&gt;</code>单纯的就表示：盘子里放了一个东西，是什么我不知道。</p>
<p>所以题主问题里的错误就在这里，<code>Plate&lt;？ extends Fruit&gt;</code>里什么都放不进去。</p>
<h4 id="下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里"><a href="#下界-lt-super-T-gt-不影响往里存，但往外取只能放在Object对象里" class="headerlink" title="下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里"></a>下界&lt;? super T&gt;不影响往里存，但往外取只能放在Object对象里</h4><p><strong>使用下界&lt;? super Fruit&gt;会使从盘子里取东西的get( )方法部分失效，只能存放到Object对象里。set( )方法正常。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Plate&lt;? super Fruit&gt; p=new Plate&lt;Fruit&gt;(new Fruit()); //存入元素正常</span><br><span class="line">p.set(new Fruit());</span><br><span class="line">p.set(new Apple()); //读取出来的东西只能存放在Object类里。</span><br><span class="line">Apple newFruit3=p.get();    //Error</span><br><span class="line">Fruit newFruit1=p.get();    //Error</span><br><span class="line">Object newFruit2=p.get();</span><br></pre></td></tr></table></figure>
<p>因为下界规定了元素的最小粒度的下限，实际上是放松了容器元素的类型控制。既然元素是Fruit的基类，那往里存粒度比Fruit小的都可以。但往外读取元素就费劲了，只有所有类的基类Object对象才能装下。但这样的话，元素的类型信息就全部丢失。</p>
<h3 id="PECS原则"><a href="#PECS原则" class="headerlink" title="PECS原则"></a>PECS原则</h3><p>最后看一下什么是PECS（Producer Extends Consumer Super）原则，已经很好理解了：</p>
<ul>
<li><strong>频繁往外读取内容的，适合用上界Extends。</strong></li>
<li><strong>经常往里插入的，适合用下界Super。</strong></li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/32402/" data-id="cjyvglqp5000ms4urdxwny88j" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-32401" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/24/32401/" class="article-date">
  <time datetime="2019-03-24T14:50:00.000Z" itemprop="datePublished">2019-03-24</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/24/32401/">Java8(forEach)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>java中的集合有两种形式Collection<e>，Map&lt;K,V&gt;</e></p>
<p>Collection类型集合<br>在JAVA7中遍历有一下几种方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; list = Arrays.asList(<span class="string">"aaaa"</span>,<span class="string">"bbbb"</span>);</span><br><span class="line"><span class="comment">//for循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i&lt; list.size();i++)&#123;</span><br><span class="line">    System.out.println(list.get(i));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//增强for循环</span></span><br><span class="line"><span class="keyword">for</span>(String str : list)&#123;</span><br><span class="line">    System.out.println(str);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//迭代器</span></span><br><span class="line">Iterator&lt;String&gt; iterator = list.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">    System.out.println(iterator.next());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JAVA8中还可以使用forEach来遍历：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(new Consumer&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s) &#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>发现和使用sort排序的写法是一样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list, new Comparator&lt;String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public int compare(String o1, String o2) &#123;</span><br><span class="line">        return o1.compareTo(o2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>发现代码量没有减少多少，那么我们在加上Lambda表达式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">list.forEach(str-&gt; System.out.println(str));</span><br></pre></td></tr></table></figure>
<p>sort排序也使用Lambda表达式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collections.sort(list,(o1,o2)-&gt;&#123;return  o1.compareTo(o2);&#125;);</span><br></pre></td></tr></table></figure>
<p>Map类型集合<br>在JAVA7中遍历有下面几种方式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String,String&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">map.put(&quot;id&quot;,&quot;11&quot;);</span><br><span class="line">map.put(&quot;name&quot;,&quot;zhangsan&quot;);</span><br><span class="line">map.put(&quot;age&quot;,&quot;30&quot;);</span><br><span class="line">for (Map.Entry&lt;String,String&gt; entry : map.entrySet())&#123;</span><br><span class="line">    System.out.println(&quot;k=&quot; + entry.getKey() + &quot;,v=&quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">for (String key : map.keySet())&#123;</span><br><span class="line">    System.out.println(&quot;k=&quot; + key + &quot;,v=&quot; + map.get(key));</span><br><span class="line">&#125;</span><br><span class="line">Iterator&lt;Map.Entry&lt;String, String&gt;&gt; iterator = map.entrySet().iterator();</span><br><span class="line">while (iterator.hasNext())&#123;</span><br><span class="line">    Map.Entry&lt;String, String&gt; entry = iterator.next();</span><br><span class="line">    System.out.println(&quot;k=&quot; + entry.getKey() + &quot;,v=&quot; + entry.getValue());</span><br><span class="line">&#125;</span><br><span class="line">for (String v : map.values())&#123;</span><br><span class="line">    System.out.println(&quot;v=&quot; + v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用JAVA8的forEach遍历，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">map.forEach(new BiConsumer&lt;String, String&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void accept(String s, String s2) &#123;</span><br><span class="line">        System.out.println(&quot;k=&quot; + s + &quot;,v=&quot; + s2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>也可以使用Lambda表达式，如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map.forEach((k,v)-&gt; System.out.println(&quot;v=&quot;+k+&quot;,v=&quot;+v));</span><br></pre></td></tr></table></figure>
<p>本文中只使用forEach，没有使用JAVA8的Stream包。<br>注：例子中出现的Consumer和BiConsumer是JAVA8中新增的函数式接口，Consumer接口中只有一个无返回结果并且只有一个泛型参数的方法，源码如下：<br><img src="/2019/03/24/32401/1.png" alt="1"></p>
<p>BiConsumer接口中提供的是一个无返回结果并且有两个泛型参数的方法，源码如下：<br><img src="/2019/03/24/32401/2.png" alt="2"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/24/32401/" data-id="cjyvglqp0000gs4ur4uyb3vkk" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-FilterandInterceptor" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/FilterandInterceptor/" class="article-date">
  <time datetime="2019-03-19T16:00:00.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/FilterandInterceptor/">拦截器和过滤器</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>GenericFilterBean<br><a href="https://blog.csdn.net/liangxw1/article/details/51095484" target="_blank" rel="noopener">https://blog.csdn.net/liangxw1/article/details/51095484</a><br>RequestInterceptor<br><a href="https://www.jianshu.com/p/919d066a07aa" target="_blank" rel="noopener">https://www.jianshu.com/p/919d066a07aa</a></p>
<p>Servlet中提供了8个监听器</p>
<p>==一类==:监听三个域对象的创建和销毁的监听器<br>对象类型    对应的监听器<br>ServletContext    ServletContextListener<br>HttpSession    HttpSessionListener<br>HttpServletRequest    ServletRequestListener</p>
<p>==二类==:监听三个域对象的属性变更的监听器.(属性添加,属性移除,属性替换)<br>对象类型    对应的监听器<br>ServletContext    ServletContextAttributeListener<br>HttpServletRequest    ServletRequestAttributeListener<br>HttpSession    HttpSessionAttributeListener</p>
<p>==三类==:监听HttpSession对象中的JavaBean的状态的改变.(绑定,解除绑定,钝化和活化)2个<br>对象类型    对应的监听器<br>HttpSession    HttpSessionBindingListener(绑定,解除绑定)<br>HttpSession    HttpSessionActivationListener(钝化和活化)<br>​</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/FilterandInterceptor/" data-id="cjyvglqp3000ks4urn1hgo6q7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-sql" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/20/sql/" class="article-date">
  <time datetime="2019-03-19T16:00:00.000Z" itemprop="datePublished">2019-03-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/20/sql/">insert和replace相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="insert-ignore-into-和insert-into"><a href="#insert-ignore-into-和insert-into" class="headerlink" title="insert ignore into 和insert into"></a>insert ignore into 和insert into</h3><p>INSERT IGNORE 与INSERT INTO的区别就是INSERT IGNORE会忽略数据库中已经存在 的数据，如果数据库没有数据，就插入新的数据，如果有数据的话就跳过这条数据。这样就可以保留数据库中已经存在数据，达到在间隙中插入数据的目的。</p>
<h3 id="replace-into"><a href="#replace-into" class="headerlink" title="replace into"></a>replace into</h3><p>replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引的话，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样；<br>REPLACE语句会返回一个数，来指示受影响的行的数目。该数是被删除和被插入的行数的和。如果对于一个单行REPLACE该数为1，则一行被插入，同时没有行被删除。如果该数大于1，则在新行被插入前，有一个或多个旧行被删除。如果表包含多个唯一索引，并且新行复制了在不同的唯一索引中的不同旧行的值，则有可能是一个单一行替换了多个旧行。</p>
<h3 id="insert-into-…-on-duplicate-key-update"><a href="#insert-into-…-on-duplicate-key-update" class="headerlink" title="insert into … on duplicate key update"></a>insert into … on duplicate key update</h3><p>insert语句的末尾添加on duplicate key update语法：如果插入行出现<strong>唯一索引或者主键</strong>重复时，则执行旧的update；如果不会导致唯一索引或者主键重复时，就直接添加新行。<br><a href="https://blog.csdn.net/qq_41070393/article/details/82422632" target="_blank" rel="noopener">https://blog.csdn.net/qq_41070393/article/details/82422632</a><br>附加条件：<br><a href="https://blog.csdn.net/hellozhxy/article/details/80945553" target="_blank" rel="noopener">https://blog.csdn.net/hellozhxy/article/details/80945553</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/20/sql/" data-id="cjyvglqpj0011s4urjj23i8c7" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-31910" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/31910/" class="article-date">
  <time datetime="2019-03-19T09:13:08.000Z" itemprop="datePublished">2019-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/31910/">Sha1加密和HmacSHA1相关</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Sha1加密：</span><br><span class="line"></span><br><span class="line">private static final char[] _HEX_DIGITS_ = &#123;&apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;3&apos;, &apos;4&apos;, &apos;5&apos;,          &apos;6&apos;, &apos;7&apos;, &apos;8&apos;, &apos;9&apos;, &apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;, &apos;f&apos;&#125;;</span><br><span class="line"></span><br><span class="line">private static String getFormattedText(byte[] bytes) &#123;      int len = bytes.length;      StringBuilder buf = new StringBuilder(len * 2);      // 把密文转换成十六进制的字符串形式      for (int j = 0; j &lt; len; j++) &#123;          buf.append(_HEX_DIGITS_[(bytes[j] &gt;&gt; 4) &amp; 0x0f]);          buf.append(_HEX_DIGITS_[bytes[j] &amp; 0x0f]);      &#125;      return buf.toString();  &#125;</span><br><span class="line"></span><br><span class="line">public String payload(@RequestBody String body, HttpServletRequest request) &#123;</span><br><span class="line"></span><br><span class="line">MessageDigest sha1 = MessageDigest.getInstance(&quot;SHA-1&quot;);  String secret = &quot;123321Zh&quot;;  sha1.update(secret.getBytes(&quot;utf-8&quot;));  byte[] digest = sha1.digest();  String result = _getFormattedText_(digest);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java HmacSHA1算法：（HMAC(散列消息身份验证码: Hashed Message Authentication Code)）<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public static String hmacSha1(String src, String key) &#123;</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line"></span><br><span class="line">SecretKeySpec signingKey = new SecretKeySpec(key.getBytes(&quot;utf-8&quot;), &quot;HmacSHA1&quot;);</span><br><span class="line"></span><br><span class="line">            Mac mac = Mac.getInstance(&quot;HmacSHA1&quot;);</span><br><span class="line"></span><br><span class="line">            mac.init(signingKey);</span><br><span class="line"></span><br><span class="line">            byte[] rawHmac = mac.doFinal(src.getBytes(&quot;utf-8&quot;));</span><br><span class="line"></span><br><span class="line">            return Hex.encodeHexString(rawHmac);</span><br><span class="line"></span><br><span class="line">&#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/31910/" data-id="cjyvglqp1000is4urhx88gajc" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-31909" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/31909/" class="article-date">
  <time datetime="2019-03-19T09:11:40.000Z" itemprop="datePublished">2019-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/31909/">0315的总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>–1.save和saveandflush<br>save不会立刻提交到数据库，flush则立刻提交生效，save可能只是修改在内存中的<br>–2.webhook<br>3.HMAC,SHA1<br>–4.ngrok<br><a href="https://tonybai.com/2015/05/14/ngrok-source-intro/" target="_blank" rel="noopener">https://tonybai.com/2015/05/14/ngrok-source-intro/</a><br>–5.node vue<br>–6.JodaTimeConverter</p>
<p>–7.jackson </p>
<p>–8.jdbctemplate namedParameterJdbcTemplate<br><a href="https://segmentfault.com/a/1190000010907688" target="_blank" rel="noopener">https://segmentfault.com/a/1190000010907688</a><br>–9.rabbit(exchange type,routingkey,queue,channel)<br>–0.zookeeper的配置属性，集群(hostname)<br>11.npm i和npm install的区别<br><a href="https://blog.csdn.net/chern1992/article/details/79193211" target="_blank" rel="noopener">https://blog.csdn.net/chern1992/article/details/79193211</a><br>–12.搭建hexo博客相关<br><a href="https://blog.csdn.net/sinat_37781304/article/details/82729029" target="_blank" rel="noopener">https://blog.csdn.net/sinat_37781304/article/details/82729029</a><br>13.阿里巴巴为什么不用 ZooKeeper 做服务发现？<br><a href="https://yq.aliyun.com/articles/599997" target="_blank" rel="noopener">https://yq.aliyun.com/articles/599997</a><br>14.what are webhooks?<br><a href="https://zapier.com/blog/what-are-webhooks/" target="_blank" rel="noopener">https://zapier.com/blog/what-are-webhooks/</a><br>You’re only limited by your imagination.</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/31909/" data-id="cjyvglqoz000fs4urehokalpn" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-31908" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/19/31908/" class="article-date">
  <time datetime="2019-03-19T08:42:32.000Z" itemprop="datePublished">2019-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/03/19/31908/">Zookeeper的搭建</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="一、Zookeeper的搭建方式"><a href="#一、Zookeeper的搭建方式" class="headerlink" title="一、Zookeeper的搭建方式"></a>一、Zookeeper的搭建方式</h1><p>Zookeeper安装方式有三种，<strong>单机模式</strong>和<strong>集群模式</strong>以及<strong>伪集群模式</strong>。</p>
<p>■ 单机模式：Zookeeper只运行在一台服务器上，适合测试环境；<br>■ 伪集群模式：就是在一台物理机上运行多个Zookeeper 实例；<br>■ 集群模式：Zookeeper运行于一个集群上，适合生产环境，这个计算机集群被称为一个“集合体”（ensemble）</p>
<p>Zookeeper通过复制来实现高可用性，只要集合体中半数以上的机器处于可用状态，它就能够保证服务继续。<strong>为什么一定要超过半数呢</strong>？这跟Zookeeper的复制策略有关：zookeeper确保对znode 树的每一个修改都会被复制到集合体中超过半数的机器上。</p>
<h2 id="1-1-Zookeeper的单机模式搭建"><a href="#1-1-Zookeeper的单机模式搭建" class="headerlink" title="1.1 Zookeeper的单机模式搭建"></a>1.1 Zookeeper的单机模式搭建</h2><p><strong>下载</strong>ZooKeeper</p>
<p><strong>解压</strong>：tar -zxvf zookeeper-3.4.5.tar.gz <strong>重命名</strong>：mv zookeeper-3.4.5 zk</p>
<p><strong>配置文件</strong>：在conf目录下删除zoo_sample.cfg文件，创建一个配置文件zoo.cfg。</p>
<p>tickTime=2000<br>dataDir=/usr/local/zk/data<br>dataLogDir=/usr/local/zk/dataLog<br>clientPort=2181</p>
<p><strong>配置环境变量</strong>：为了今后操作方便，我们需要对Zookeeper的环境变量进行配置，方法如下在/etc/profile文件中加入如下内容：</p>
<p>export ZOOKEEPER_HOME=/usr/local/zk<br>export PATH=.:$HADOOP_HOME/bin:$ZOOKEEPER_HOME/bin:$JAVA_HOME/bin:$PATH</p>
<p><strong>启动</strong>ZooKeeper的Server：zkServer.sh start；<br><strong>关闭</strong>ZooKeeper的Server：zkServer.sh stop</p>
<h2 id="1-2-Zookeeper的伪集群模式搭建"><a href="#1-2-Zookeeper的伪集群模式搭建" class="headerlink" title="1.2 Zookeeper的伪集群模式搭建"></a>1.2 Zookeeper的伪集群模式搭建</h2><p>Zookeeper不但可以在单机上运行单机模式Zookeeper，而且可以在单机模拟集群模式 Zookeeper的运行，也就是将不同节点运行在同一台机器。我们知道伪分布模式下Hadoop的操作和分布式模式下有着很大的不同，但是在集群为分布 式模式下对Zookeeper的操作却和集群模式下没有本质的区别。显然，集群伪分布式模式为我们体验Zookeeper和做一些尝试性的实验提供了很大 的便利。比如，我们在实验的时候，可以先使用少量数据在集群伪分布模式下进行测试。当测试可行的时候，再将数据移植到集群模式进行真实的数据实验。这样不 但保证了它的可行性，同时大大提高了实验的效率。这种搭建方式，比较简便，成本比较低，适合测试和学习，如果你的手头机器不足，就可以在一台机器上部署了 3个server。</p>
<h3 id="1-2-1-注意事项"><a href="#1-2-1-注意事项" class="headerlink" title="1.2.1. 注意事项"></a><strong>1.2.1. 注意事项</strong></h3><p>在一台机器上部署了3个server，需要注意的是在集群为分布式模式下我们使用的每个配置文档模拟一台机器，也就是说单台机器及上运行多个Zookeeper实例。但是，必须保证每个配置文档的各个端口号不能冲突，除了clientPort不同之外，dataDir也不同。另外，还要在dataDir所对应的目录中创建myid文件来指定对应的Zookeeper服务器实例。</p>
<p>■ clientPort端口：如果在1台机器上部署多个server，那么每台机器都要不同的 clientPort，比如 server1是2181,server2是2182，server3是2183</p>
<p>■ dataDir和dataLogDir：dataDir和dataLogDir也需要区分下，将数据文件和日志文件分开存放，同时每个server的这两变量所对应的路径都是不同的</p>
<p>■ server.X和myid： server.X 这个数字就是对应，data/myid中的数字。在3个server的myid文件中分别写入了0，1，2，那么每个server中的zoo.cfg都配 server.0 server.2,server.3就行了。因为在同一台机器上，后面连着的2个端口，3个server都不要一样，否则端口冲突</p>
<p>下面是我所配置的集群伪分布模式，分别通过zoo1.cfg、zoo2.cfg、zoo3.cfg来模拟由三台机器的Zookeeper集群,<br>代码清单 zoo1.cfg如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/usr/local/zk/data_1</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2181</span><br><span class="line"></span><br><span class="line">#the location of the log file</span><br><span class="line">dataLogDir=/usr/local/zk/logs_1</span><br><span class="line"></span><br><span class="line">server.0=localhost:2287:3387</span><br><span class="line">server.1=localhost:2288:3388</span><br><span class="line">server.2=localhost:2289:3389</span><br></pre></td></tr></table></figure>
<p>代码清单  zoo2.cfg如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/usr/local/zk/data_2</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2182</span><br><span class="line"></span><br><span class="line">#the location of the log file</span><br><span class="line">dataLogDir=/usr/local/zk/logs_2</span><br><span class="line"></span><br><span class="line">server.0=localhost:2287:3387</span><br><span class="line">server.1=localhost:2288:3388</span><br><span class="line">server.2=localhost:2289:3389</span><br></pre></td></tr></table></figure></p>
<p>代码清单 zoo3.cfg如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/usr/local/zk/data_3</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2183</span><br><span class="line"></span><br><span class="line">#the location of the log file</span><br><span class="line">dataLogDir=/usr/local/zk/logs_3</span><br><span class="line"></span><br><span class="line">server.0=localhost:2287:3387</span><br><span class="line">server.1=localhost:2288:3388</span><br><span class="line">server.2=localhost:2289:3389</span><br></pre></td></tr></table></figure></p>
<h3 id="1-2-2-启动"><a href="#1-2-2-启动" class="headerlink" title="1.2.2 启动"></a>1.2.2 启动</h3><p>在集群为分布式下，我们只有一台机器，按时要运行三个Zookeeper实例。此时，如果在使用单机模式的启动命令是行不通的。此时，只要通过下面三条命令就能运行前面所配置的Zookeeper服务。如下所示：</p>
<p>zkServer.sh start zoo1.sh<br>zkServer.sh start zoo2.sh<br>zkServer.sh start zoo3.sh</p>
<p>启动过程，如下图所示：</p>
<p><img src="/2019/03/19/31908/1.png" alt="1"></p>
<p> 启动结果，如下图所示：</p>
<p><img src="/2019/03/19/31908/2.png" alt="2"></p>
<p>在运行完第一条指令之后，会出现一些错误异常，产生异常信息的原因是由于Zookeeper 服务的每个实例都拥有全局配置信息，他们在启动的时候会随时随地的进行Leader选举操作。此时，第一个启动的Zookeeper需要和另外两个 Zookeeper实例进行通信。但是，另外两个Zookeeper实例还没有启动起来，因此就产生了这的异样信息。我们直接将其忽略即可，待把图中“2 号”和“3号”Zookeeper实例启动起来之后，相应的异常信息自然会消失。此时，可以通过下面三条命令，来查询。</p>
<p> zkServer.sh status zoo1.cfg<br> zkServer.sh status zoo2.cfg<br> zkServer.sh status zoo3.cfg</p>
<p>Zookeeper服务的运行状态，如下图所示:</p>
<p><img src="/2019/03/19/31908/3.png" alt="3"></p>
<h2 id="1-3-Zookeeper的集群模式搭建"><a href="#1-3-Zookeeper的集群模式搭建" class="headerlink" title="1.3  Zookeeper的集群模式搭建"></a>1.3  Zookeeper的集群模式搭建</h2><p>为了获得可靠地Zookeeper服务，用户应该在一个机群上部署Zookeeper。只要机群上大多数的Zookeeper服务启动了，那么总的 Zookeeper服务将是可用的。集群的配置方式，和前两种类似，同样需要进行环境变量的配置。在每台机器上conf/zoo.cf配置文件的参数设置 相同</p>
<h3 id="1-3-1-创建myid"><a href="#1-3-1-创建myid" class="headerlink" title="1.3.1 创建myid"></a>1.3.1 创建myid</h3><p>在dataDir(/usr/local/zk/data)目录创建myid文件</p>
<p>Server0机器的内容为：0<br>Server1机器的内容为：1<br>Server2机器的内容为：2</p>
<h3 id="1-3-2-编写配置文件"><a href="#1-3-2-编写配置文件" class="headerlink" title="1.3.2 编写配置文件"></a>1.3.2 编写配置文件</h3><p>在conf目录下删除zoo_sample.cfg文件，创建一个配置文件zoo.cfg，如下所示,代码清单  zoo.cfg中的参数设置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># The number of milliseconds of each tick</span><br><span class="line">tickTime=2000</span><br><span class="line"></span><br><span class="line"># The number of ticks that the initial</span><br><span class="line"># synchronization phase can take</span><br><span class="line">initLimit=10</span><br><span class="line"></span><br><span class="line"># The number of ticks that can pass between</span><br><span class="line"># sending a request and getting an acknowledgement</span><br><span class="line">syncLimit=5</span><br><span class="line"></span><br><span class="line"># the directory where the snapshot is stored.</span><br><span class="line">dataDir=/usr/local/zk/data</span><br><span class="line"></span><br><span class="line"># the port at which the clients will connect</span><br><span class="line">clientPort=2183</span><br><span class="line"></span><br><span class="line">#the location of the log file</span><br><span class="line">dataLogDir=/usr/local/zk/log</span><br><span class="line"></span><br><span class="line">server.0=hadoop:2288:3388</span><br><span class="line">server.1=hadoop0:2288:3388</span><br><span class="line">server.2=hadoop1:2288:3388</span><br></pre></td></tr></table></figure>
<h3 id="1-3-3-启动"><a href="#1-3-3-启动" class="headerlink" title="1.3.3 启动"></a>1.3.3 启动</h3><p>分别在3台机器上启动ZooKeeper的Server：zkServer.sh start；</p>
<h1 id="二、Zookeeper的配置"><a href="#二、Zookeeper的配置" class="headerlink" title="二、Zookeeper的配置"></a>二、Zookeeper的配置</h1><p>Zookeeper的功能特性是通过Zookeeper配置文件来进行控制管理的(zoo.cfg).这样的设计其实有其自身的原因，通过前面对Zookeeper的配置可以看出，在对Zookeeper集群进行配置的时候，它的配置文档是完全相同的。集群伪分布模式中，有少部分是不同的。这样的配置方式使得在部署Zookeeper服务的时候非常方便。如果服务器使用不同的配置文件，必须确保不同配置文件中的服务器列表相匹配。</p>
<p>在设置Zookeeper配置文档时候，某些参数是可选的，某些是必须的。这些必须参数就构成了Zookeeper配置文档的最低配置要求。另外，若要对Zookeeper进行更详细的配置，可以参考下面的内容。</p>
<h2 id="2-1-基本配置"><a href="#2-1-基本配置" class="headerlink" title="2.1 基本配置"></a>2.1 基本配置</h2><p>下面是在最低配置要求中必须配置的参数：</p>
<p><strong>(1) client</strong>：监听客户端连接的端口。<br><strong>(2) tickTime</strong>：基本事件单元，这个时间是作为Zookeeper服务器之间或客户端与服务器之间维持心跳的时间间隔，每隔tickTime时间就会发送一个心跳；最小 的session过期时间为2倍tickTime 　　<br><strong>dataDir</strong>：存储内存中数据库快照的位置，如果不设置参数，更新食物的日志将被存储到默认位置。</p>
<blockquote>
<p>应该谨慎的选择日志存放的位置，使用专用的日志存储设备能够大大提高系统的性能，如果将日志存储在比较繁忙的存储设备上，那么将会很大程度上影像系统性能。</p>
</blockquote>
<h2 id="2-2-高级配置"><a href="#2-2-高级配置" class="headerlink" title="2.2 高级配置"></a>2.2 高级配置</h2><p>下面是高级配置参数中可选配置参数，用户可以使用下面的参数来更好的规定Zookeeper的行为：</p>
<p><strong>(1) dataLogdDir</strong></p>
<p>这个操作让管理机器把事务日志写入“dataLogDir”所指定的目录中，而不是“dataDir”所指定的目录。这将允许使用一个专用的日志设备，帮助我们避免日志和快照的竞争。配置如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># the directory where the snapshot is stored</span><br><span class="line">   dataDir=/usr/local/zk/data</span><br></pre></td></tr></table></figure>
<p><strong>(2)maxClientCnxns</strong></p>
<p>这个操作将限制连接到Zookeeper的客户端数量，并限制并发连接的数量，通过IP来区分不同的客户端。此配置选项可以阻止某些类别的Dos攻击。将他设置为零或忽略不进行设置将会取消对并发连接的限制。</p>
<p>例如，此时我们将maxClientCnxns的值设为1，如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># set maxClientCnxns</span><br><span class="line">   maxClientCnxns=1</span><br></pre></td></tr></table></figure></p>
<p>启动Zookeeper之后，首先用一个客户端连接到Zookeeper服务器上。之后如果有第二个客户端尝试对Zookeeper进行连接，或者有某些隐式的对客户端的连接操作，将会触发Zookeeper的上述配置。</p>
<p><strong>(3)minSessionTimeout和maxSessionTimeout</strong></p>
<p>即最小的会话超时和最大的会话超时时间。在默认情况下，minSession=2<em>tickTime；maxSession=20</em>tickTime。</p>
<h2 id="2-3-集群配置"><a href="#2-3-集群配置" class="headerlink" title="2.3 集群配置"></a>2.3 集群配置</h2><p><strong>(1) initLimit</strong></p>
<p>此配置表示，允许follower(相对于Leaderer言的“客户端”)连接并同步到Leader的初始化连接时间，以tickTime为单位。当初始化连接时间超过该值，则表示连接失败。</p>
<p><strong>(2) syncLimit</strong></p>
<p>此配置项表示Leader与Follower之间发送消息时，请求和应答时间长度。如果follower在设置时间内不能与leader通信，那么此follower将会被丢弃。</p>
<p><strong>(3) server.A=B：C：D</strong></p>
<p>A：其中 A 是一个数字，表示这个是服务器的编号；<br>B：是这个服务器的 ip 地址；<br>C：Leader选举的端口；<br>D：Zookeeper服务器之间的通信端口。</p>
<p><strong>(4) myid 和 zoo.cfg</strong></p>
<p>除了修改 zoo.cfg 配置文件，集群模式下还要配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面就有一个数据就是 A 的值，Zookeeper 启动时会读取这个文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是那个 server。</p>
<h1 id="三、搭建ZooKeeper服务器集群"><a href="#三、搭建ZooKeeper服务器集群" class="headerlink" title="三、搭建ZooKeeper服务器集群"></a>三、搭建ZooKeeper服务器集群</h1><p><strong>搭建要求：</strong></p>
<p>(1) zk服务器集群规模不小于3个节点<br>(2) 要求各服务器之间系统时间要保持一致。</p>
<h2 id="3-1-安装配置ZK"><a href="#3-1-安装配置ZK" class="headerlink" title="3.1 安装配置ZK"></a>3.1 安装配置ZK</h2><p><strong>(1)</strong> 使用WinScp将Zk传输到Hadoop主机上的/usr/local，我用的版本是zookeeper-3.4.5.tar.gz。</p>
<p><strong>(2)</strong> 在hadoop的/usr/local目录下，解压缩zk….tar.gz，设置环境变量</p>
<p><strong> 解压缩</strong>: 在/usr/local目录下，执行命令：tar -zxvf zookeeper-3.4.5.tar.gz，如下图所示:<br><img src="/2019/03/19/31908/4.png" alt="4"></p>
<p><strong>重命名</strong>：解压后将文件夹，重命名为zk，执行命令： mv zookeeper-3.4.5 zk，如下图所示:<br><img src="/2019/03/19/31908/5.png" alt="5"></p>
<p><strong>设置环境变量</strong>：执行命令： vi /etc/profile ，添加 ：export ZOOKEEPER_HOME=/usr/local/zk，如图2.3所示的内容。执行命令：source /etc/profile 如下图所示:</p>
<p><img src="/2019/03/19/31908/6.png" alt="6"></p>
<p><img src="/2019/03/19/31908/15.png" alt="15"></p>
<h2 id="3-2-修改ZK配置文件"><a href="#3-2-修改ZK配置文件" class="headerlink" title="3.2 修改ZK配置文件"></a>3.2 修改ZK配置文件</h2><p><strong>(1) 重命名</strong>：将/usr/local/zk/conf目录下zoo_sample.cfg，重命名为zoo.cfg，执行命令：mv zoo_sample.cfg zoo.cfg。如如下图所示:<br><img src="/2019/03/19/31908/7.png" alt="7"></p>
<p><strong>(2) 查看</strong>：在/usr/local/zk/conf目录下，修改文件 vi zoo.cfg，文件内容如下图所示。在该文件中dataDir表示文件存放目录，它的默认设置为/tmp/zookeeper这是一个临时存放目录，每 次重启后会丢失，在这我们自己设一个目录，/usr/local/zk/data。</p>
<p><img src="/2019/03/19/31908/8.png" alt="8"></p>
<p><strong>(3) 创建文件夹</strong>：mkdir /usr/local/zk/data</p>
<p><strong>(4) 创建myid</strong>：在data目录下，创建文件myid，值为0；vi myid ;内容为0。</p>
<p><strong>(5) 编辑</strong>：编辑该文件，执行vi zoo.cfg ，修改dataDir=/usr/local/zk/data。</p>
<p><strong>新增</strong>：</p>
<p>server.0=hadoop:2888:3888<br>server.1=hadoop0:2888:3888<br>server.2=hadoop1:2888:3888</p>
<blockquote>
<p>tickTime ：这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个 tickTime  时间就会发送一个心跳；</p>
<p>dataDir：顾名思义就是 Zookeeper 保存数据的目录，默认情况下，Zookeeper 将写数据的日志文件也保存在这个目录里；</p>
<p>clientPort：这个端口就是客户端连接 Zookeeper 服务器的端口，Zookeeper 会监听这个端口，接受客户端的访问请求。</p>
<p>当这些配置项配置好后，就可以启动 Zookeeper 了，启动后使用命令echo ruok | nc localhost 2181检查 Zookeeper 是否已经在服务。</p>
</blockquote>
<h2 id="2-3-配置其他节点"><a href="#2-3-配置其他节点" class="headerlink" title="2.3 配置其他节点"></a>2.3 配置其他节点</h2><p><strong>(1)</strong> 把haooop主机的zk目录和/etc/profile目录，复制到hadoop0和hadoop1中。执行命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">scp -r /usr/local/zk/ hadoop0:/usr/local/</span><br><span class="line">scp -r /usr/local/zk/ hadoop1:/usr/local/</span><br><span class="line">　　　　　　scp /etc/profile hadoop0:/etc/</span><br><span class="line">　　　　　　scp /etc/profile hadoop1:/etc/</span><br><span class="line"></span><br><span class="line">　　　　　　ssh hadoop0</span><br><span class="line">　　　　　　suorce /etc/profile</span><br><span class="line">　　　　　　vi /usr/local/zk/data/myid</span><br><span class="line">　　　　　　exit</span><br><span class="line"></span><br><span class="line">　　　　　　ssh hadoop1</span><br><span class="line">　　　　　　suorce /etc/profile</span><br><span class="line">　　　　　　vi /usr/local/zk/data/myid</span><br><span class="line">　　　　　　exit</span><br></pre></td></tr></table></figure></p>
<p><strong>(2)</strong> 把hadoop1中相应的myid的值改为1，把hadoop2中相应的myid的值改为2。　　　</p>
<h1 id="四、启动检验"><a href="#四、启动检验" class="headerlink" title="四、启动检验"></a>四、启动检验</h1><p><strong>(1)</strong> 启动，在三个节点上分别执行命令zkServer.sh start</p>
<p><strong>hadoop节点</strong>：</p>
<p><img src="/2019/03/19/31908/9.png" alt="9"></p>
<p><strong>hadoop0节点</strong>：</p>
<p><img src="/2019/03/19/31908/10.png" alt="10"></p>
<p><strong>hadoop1节点</strong>：</p>
<p><img src="/2019/03/19/31908/11.png" alt="11"></p>
<p><strong>(2)</strong> 检验，在三个节点上分别执行命令zkServer.sh status，从下面的图中我们会发现hadoop和hadoop1为Follower，hadoop0为Leader。</p>
<p><strong>hadoop节点</strong>：</p>
<p><img src="/2019/03/19/31908/12.png" alt="12"></p>
<p><strong>hadoop0节点</strong>：</p>
<p><img src="/2019/03/19/31908/13.png" alt="13"></p>
<p><strong>hadoop1节点</strong>：</p>
<p><img src="/2019/03/19/31908/14.png" alt="14"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/19/31908/" data-id="cjyvglqq2001bs4ur4saiu0xy" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/4/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/page/6/">6</a><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/6/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/03/0707-md/">0707.md</a>
          </li>
        
          <li>
            <a href="/2019/06/16/Collectors-toMap的问题/">Collectors.toMap的问题</a>
          </li>
        
          <li>
            <a href="/2019/06/16/hystrix请求命令/">hystrix请求命令</a>
          </li>
        
          <li>
            <a href="/2019/06/16/cas单点登陆/">cas单点登陆</a>
          </li>
        
          <li>
            <a href="/2019/06/16/paxos算法/">paxos算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Zavier<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/technology" class="mobile-nav-link">Technology</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>