<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="utf-8">
  

  
  <title>Actionzh</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="Actionzh">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Actionzh">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Actionzh">
  
    <link rel="alternate" href="/atom.xml" title="Actionzh" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Actionzh</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
          <a class="main-nav-link" href="/technology">Technology</a>
        
          <a class="main-nav-link" href="/about">About</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-webService" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/webService/" class="article-date">
  <time datetime="2019-04-16T10:53:08.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/webService/">webservice</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="一、序言"><a href="#一、序言" class="headerlink" title="一、序言"></a>一、序言</h2><p>　　大家或多或少都听过 WebService（Web服务），有一段时间很多计算机期刊、书籍和网站都大肆的提及和宣传WebService技术，其中不乏很多吹嘘和做广告的成 分。但是不得不承认的是WebService真的是一门新兴和有前途的技术，那么WebService到底是什么？何时应该用？</p>
<p>　　当前的应用程序开发逐步的呈现了两种迥然不同的倾向：一种是基于浏览器的瘦客户端应用程序，一种是基于浏览器的富客户端应用程序（RIA），当然后一种技术相对来说更加的时髦一些（如现在很流行的Html5技术），这里主要讲前者。</p>
<p>　　基于浏览器的瘦客户端应用程序并不是 因为瘦客户能够提供更好的用户界面，而是因为它能够避免花在桌面应用程序发布上的高成本。发布桌面应用程序成本很高，一半是因为应用程序安装和配置的问 题，另一半是因为客户和服务器之间通信的问题。传统的Windows富客户应用程序使用DCOM来与服务器进行通信和调用远程对象。配置好DCOM使其在 一个大型的网络中正常工作将是一个极富挑战性的工作，同时也是许多IT工程师的噩梦。事实上，许多IT工程师宁愿忍受浏览器所带来的功能限制，也不愿在局 域网上去运行一个DCOM。关于客户端与服务器的通信问题，一个完美的解决方法是使用HTTP协议来通信。这是因为任何运行Web浏览器的机器都在使用 HTTP协议。同时，当前许多防火墙也配置为只允许HTTP连接。许多商用程序还面临另一个问题，那就是与其他程序的互操作性。如果所有的应用程序都是使 用COM或.NET语言写的，并且都运行在Windows平台上，那就天下太平了。然而，事实上大多数商业数据仍然在大型主机上以非关系文件(VSAM) 的形式存放，并由COBOL语言编写的大型机程序访问。而且，目前还有很多商用程序继续在使用C++、Java、Visual Basic和其他各种各样 的语言编写。现在，除了最简单的程序之外，所有的应用程序都需要与运行在其他异构平台上的应用程序集成并进行数据交换。这样的任务通常都是由特殊的方法， 如文件传输和分析，消息队列，还有仅适用于某些情况的的API，如IBM的高级程序到程序交流(APPC)等来完成的。在以前，没有一个应用程序通信标 准，是独立于平台、组建模型和编程语言的。只有通过Web Service，客户端和服务器才能够自由的用HTTP进行通信，不论两个程序的平台和编程语言是什么。</p>
<h2 id="二、WebService到底是什么"><a href="#二、WebService到底是什么" class="headerlink" title="二、WebService到底是什么"></a>二、WebService到底是什么</h2><p>   一言以蔽之：<strong>WebService是一种跨编程语言和跨操作系统平台的远程调用技术。</strong></p>
<p>   所谓跨编程语言和跨操作平台，就是说服务端程序采用java编写，客户端程序则可以采用其他编程语言编写，反之亦然！跨操作系统平台则是指服务端程序和客户端程序可以在不同的操作系统上运行。</p>
<pre><code>所谓远程调用，就是一台计算机a上 的一个程序可以调用到另外一台计算机b上的一个对象的方法，譬如，银联提供给商场的pos刷卡系统，商场的POS机转账调用的转账方法的代码其实是跑在银 行服务器上。再比如，amazon，天气预报系统，淘宝网，校内网，百度等把自己的系统服务以webservice服务的形式暴露出来，让第三方网站和程 序可以调用这些服务功能，这样扩展了自己系统的市场占有率，往大的概念上吹，就是所谓的SOA应用。
</code></pre><p>   其实可以从多个角度来理解 WebService，从表面上看，WebService就是一个应用程序向外界暴露出一个能通过Web进行调用的API，也就是说能用编程的方法通过 Web来调用这个应用程序。我们把调用这个WebService的应用程序叫做客户端，而把提供这个WebService的应用程序叫做服务端。从深层次 看，WebService是建立可互操作的分布式应用程序的新平台，是一个平台，是一套标准。它定义了应用程序如何在Web上实现互操作性，你可以用任何 你喜欢的语言，在任何你喜欢的平台上写Web service ，只要我们可以通过Web service标准对这些服务进行查询和访问。 </p>
<p>   WebService平台需要一套协议来实现分布式应用程序的创建。任何平台都有它的数据表示方法和类型系统。要实现互操作性，WebService平台 必须提供一套标准的类型系统，用于沟通不同平台、编程语言和组件模型中的不同类型系统。Web service平台必须提供一种标准来描述 Web service，让客户可以得到足够的信息来调用这个Web service。最后，我们还必须有一种方法来对这个Web service进行远 程调用,这种方法实际是一种远程过程调用协议(RPC)。为了达到互操作性，这种RPC协议还必须与平台和编程语言无关。</p>
<h2 id="三、WebService平台技术"><a href="#三、WebService平台技术" class="headerlink" title="三、WebService平台技术"></a>三、WebService平台技术</h2><p>  XML+XSD,SOAP和WSDL就是构成WebService平台的三大技术。</p>
<h3 id="3-1、XML-XSD"><a href="#3-1、XML-XSD" class="headerlink" title="3.1、XML+XSD"></a>3.1、XML+XSD</h3><p>　　WebService采用HTTP协议传输数据，采用XML格式封装数据（即XML中说明调用远程服务对象的哪个方法，传递的参数是什么，以及服务对象的 返回结果是什么）。XML是WebService平台中表示数据的格式。除了易于建立和易于分析外，XML主要的优点在于它既是平台无关的，又是厂商无关 的。无关性是比技术优越性更重要的：软件厂商是不会选择一个由竞争对手所发明的技术的。 </p>
<p>　　XML解决了数据表示的问题，但它没有定义一套标准的数据类型，更没有说怎么去扩展这套数据类型。例如，整形数到底代表什么？16位，32位，64位？这 些细节对实现互操作性很重要。XML Schema(XSD)就是专门解决这个问题的一套标准。它定义了一套标准的数据类型，并给出了一种语言来扩展这套数据类型。WebService平台就 是用XSD来作为其数据类型系统的。当你用某种语言(如VB.NET或C#)来构造一个Web service时，为了符合WebService标准，所 有你使用的数据类型都必须被转换为XSD类型。你用的工具可能已经自动帮你完成了这个转换，但你很可能会根据你的需要修改一下转换过程。</p>
<h3 id="3-2、SOAP"><a href="#3-2、SOAP" class="headerlink" title="3.2、SOAP"></a>3.2、SOAP</h3><p>   WebService通过HTTP协议发送请求和接收结果时，发送的请求内容和结果内容都采用XML格式封装，并增加了一些特定的HTTP消息头，以说明 HTTP消息的内容格式，这些特定的HTTP消息头和XML内容格式就是SOAP协议。SOAP提供了标准的RPC方法来调用Web Service。</p>
<p>  <strong>SOAP协议 = HTTP协议 + XML数据格式</strong></p>
<p>  SOAP协议定义了SOAP消息的格式，SOAP协议是基于HTTP协议的，SOAP也是基于XML和XSD的，XML是SOAP的数据编码方式。打个比 喻：HTTP就是普通公路，XML就是中间的绿色隔离带和两边的防护栏，SOAP就是普通公路经过加隔离带和防护栏改造过的高速公路。</p>
<h3 id="3-3、WSDL"><a href="#3-3、WSDL" class="headerlink" title="3.3、WSDL"></a>3.3、WSDL</h3><p>　　好比我们去商店买东西，首先要知道商店里有什么东西可买，然后再来购买，商家的做法就是张贴广告海报。 WebService也一样，WebService客户端要调用一个WebService服务，首先要有知道这个服务的地址在哪，以及这个服务里有什么方 法可以调用，所以，WebService务器端首先要通过一个WSDL文件来说明自己家里有啥服务可以对外调用，服务是什么（服务中有哪些方法，方法接受 的参数是什么，返回值是什么），服务的网络地址用哪个url地址表示，服务通过什么方式来调用。</p>
<p>　　WSDL(Web Services Description Language)就是这样一个基于XML的语言，用于描述Web Service及其函数、参数和返回值。它是WebService客户端和服务器端都 能理解的标准格式。因为是基于XML的，所以WSDL既是机器可阅读的，又是人可阅读的，这将是一个很大的好处。一些最新的开发工具既能根据你的 Web service生成WSDL文档，又能导入WSDL文档，生成调用相应WebService的代理类代码。</p>
<p>　　WSDL 文件保存在Web服务器上，通过一个url地址就可以访问到它。客户端要调用一个WebService服务之前，要知道该服务的WSDL文件的地址。 WebService服务提供商可以通过两种方式来暴露它的WSDL文件地址：1.注册到UDDI服务器，以便被人查找；2.直接告诉给客户端调用者。</p>
<h2 id="四、WebService开发"><a href="#四、WebService开发" class="headerlink" title="四、WebService开发"></a>四、WebService开发</h2><p>　　WebService开发可以分为服务器端开发和客户端开发两个方面</p>
<h3 id="4-1、服务端开发"><a href="#4-1、服务端开发" class="headerlink" title="4.1、服务端开发"></a>4.1、服务端开发</h3><p>　　把公司内部系统的业务方法发布成WebService服务，供远程合作单位和个人调用。(借助一些WebService框架可以很轻松地把自己的业务对象发布成WebService服务，Java方面的典型WebService框架包括：axis，xfire，cxf 等，java ee服务器通常也支持发布WebService服务，例如JBoss。)</p>
<h3 id="4-2、客户端开发"><a href="#4-2、客户端开发" class="headerlink" title="4.2、客户端开发"></a>4.2、客户端开发</h3><p>　　调用别人发布的WebService服务，大多数人从事的开发都属于这个方面，例如，调用天气预报WebService服务。（使用厂 商的WSDL2Java之类的工具生成静态调用的代理类代码；使用厂商提供的客户端编程API类；使用SUN公司早期标准的jax-rpc开发包；使用 SUN公司最新标准的jax-ws开发包。当然SUN已被ORACLE收购)</p>
<h3 id="4-3、WebService-的工作调用原理"><a href="#4-3、WebService-的工作调用原理" class="headerlink" title="4.3、WebService 的工作调用原理"></a>4.3、WebService 的工作调用原理</h3><p>   对客户端而言，我们给这各类WebService客户端API传递wsdl文件的url地址，这些API就会创建出底层的代理类，我调用 这些代理，就可以访问到webservice服务。代理类把客户端的方法调用变成soap格式的请求数据再通过HTTP协议发出去，并把接收到的soap 数据变成返回值返回。对服务端而言，各类WebService框架的本质就是一个大大的Servlet，当远程调用客户端给它通过http协议发送过来 soap格式的请求数据时，它分析这个数据，就知道要调用哪个java类的哪个方法，于是去查找或创建这个对象，并调用其方法，再把方法返回的结果包装成 soap格式的数据，通过http响应消息回给客户端。</p>
<h2 id="五、适用场合"><a href="#五、适用场合" class="headerlink" title="五、适用场合"></a>五、适用场合</h2><h3 id="1、跨防火墙通信"><a href="#1、跨防火墙通信" class="headerlink" title="1、跨防火墙通信"></a>1、跨防火墙通信</h3><p>　　如果应用程序有成千上万的用户，而且分布在世界各地，那么客户端和服务器之间的通信将是一个棘手的问题。因为客户端和服务器之间通常会有防火墙或者代理服 务器。在这种情况下，使用DCOM就不是那么简单，通常也不便于把客户端程序发布到数量如此庞大的每一个用户手中。传统的做法是，选择用浏览器作为客户 端，写下一大堆ASP页面，把应用程序的中间层暴露给最终用户。这样做的结果是开发难度大，程序很难维护。如果中间层组件换成WebService的话， 就可以从用户界面直接调用中间层组件。从大多数人的经验来看，在一个用户界面和中间层有较多交互的应用程序中，使用WebService这种结构，可以节 省花在用户界面编程上20%的开发时间。</p>
<h3 id="2、应用程序集成"><a href="#2、应用程序集成" class="headerlink" title="2、应用程序集成"></a>2、应用程序集成</h3><p>　　企业级的应用程序开发者都知道，企业里经常都要把用不同语言写成的、在不同平台上运行的各种程序集成起来，而这种集成将花费很大的开发力量。应用程序经常 需要从运行在IBM主机上的程序中获取数据；或者把数据发送到主机或UNIX应用程序中去。即使在同一个平台上，不同软件厂商生产的各种软件也常常需要集 成起来。通过WebService，可以很容易的集成不同结构的应用程序。</p>
<h3 id="3、B2B集成"><a href="#3、B2B集成" class="headerlink" title="3、B2B集成"></a>3、B2B集成</h3><p>　　用WebService集成应用程序，可以使公司内部的商务处理更加自动化。但当交易跨越供应商和客户、突破公司的界限时会怎么样呢？跨公司的商务交易集成通常叫做B2B集成。WebService是B2B集成成功的关键。通过WebService，公司可以把关键的商务应用“暴露”给指定的供应商和客户。例如，把电子下单系统和电子发票系统“暴露”出来，客户就可以以电子的方式发送订单，供应商则可以以电子的方式发送原料采购发票。当然，这并不是一个 新的概念，EDI(电子文档交换)早就是这样了。但是，WebService的实现要比EDI简单得多，而且WebService运行在Internet 上，在世界任何地方都可轻易实现，其运行成本就相对较低。不过，WebService并不像EDI那样，是文档交换或B2B集成的完整解决方案。 WebService只是B2B集成的一个关键部分，还需要许多其它的部分才能实现集成。</p>
<p>　　用WebService来实现B2B集成的最大好处在于可以轻易实现互操作性。只要把商务逻辑“暴露”出来，成为WebService，就可以让任何指定 的合作伙伴调用这些商务逻辑，而不管他们的系统在什么平台上运行，使用什么开发语言。这样就大大减少了花在B2B集成上的时间和成本，让许多原本无法承受 EDI的中小企业也能实现B2B集成。</p>
<h3 id="4、软件和数据重用"><a href="#4、软件和数据重用" class="headerlink" title="4、软件和数据重用"></a>4、软件和数据重用</h3><pre><code>软件重用是一个很大的主题，重用的形式很多，重用的程度有大有小。最基本的形式是源代码模块或者类一级的重用，一种形式是二进制形式的组件重用。采用 WebService应用程序可以用标准的方法把功能和数据“暴露”出来，供其它应用程序使用，达到业务级重用。
</code></pre><h2 id="六、不适用场合"><a href="#六、不适用场合" class="headerlink" title="六、不适用场合"></a>六、不适用场合</h2><h3 id="1、单机应用程序"><a href="#1、单机应用程序" class="headerlink" title="1、单机应用程序"></a>1、单机应用程序</h3><pre><code>目前，企业和个人还使用着很多桌面应用程序。其中一些只需要与本机上的其它程序通信。在这种情况下，最好就不要用WebService，只要用本地的 API就可以了。COM非常适合于在这种情况下工作，因为它既小又快。运行在同一台服务器上的服务器软件也是这样。最好直接用COM或其它本地的API来 进行应用程序间的调用。当然WebService也能用在这些场合，但那样不仅消耗太大，而且不会带来任何好处。
</code></pre><h3 id="2、局域网的同构应用程序"><a href="#2、局域网的同构应用程序" class="headerlink" title="2、局域网的同构应用程序"></a>2、局域网的同构应用程序</h3><pre><code>在许多应用中，所有的程序都是用VB或VC开发的，都在Windows平台下使用COM，都运行在同一个局域网上。例如，有两个服务器应用程序需要相互通 信，或者有一个Win32或WinForm的客户程序要连接局域网上另一个服务器的程序。在这些程序里，使用DCOM会比SOAP/HTTP有效得多。与 此相类似，如果一个.NET程序要连接到局域网上的另一个.NET程序，应该使用.NETremoting。有趣的是，在.NETremoting 中，也可以指定使用SOAP/HTTP来进行WebService调用。不过最好还是直接通过TCP进行RPC调用，那样会有效得多。
</code></pre><p>　　转载网上的一篇讲得比较好的文章，具体链接地址忘记了，原作者要是要是看到还望提醒一声，我好加上去。</p>
<p>链接：<a href="https://www.cnblogs.com/xdp-gacl/category/629559.html" target="_blank" rel="noopener">https://www.cnblogs.com/xdp-gacl/category/629559.html</a></p>
<p>cxf:<br><a href="https://www.cnblogs.com/frankliiu-java/articles/1641949.html" target="_blank" rel="noopener">https://www.cnblogs.com/frankliiu-java/articles/1641949.html</a><br><a href="https://www.cnblogs.com/jiyukai/p/9249103.html" target="_blank" rel="noopener">https://www.cnblogs.com/jiyukai/p/9249103.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/webService/" data-id="cjyvgp28i001jswurd32omjx9" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Java 8stream" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/Java 8stream/" class="article-date">
  <time datetime="2019-04-16T10:53:08.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/Java 8stream/">Java 8 Stream</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="Java-8-Stream"><a href="#Java-8-Stream" class="headerlink" title="Java 8 Stream"></a>Java 8 Stream</h1><p>Java 8 API添加了一个新的抽象称为流Stream，可以让你以一种声明的方式处理数据。</p>
<p>Stream 使用一种类似用 SQL 语句从数据库查询数据的直观方式来提供一种对 Java 集合运算和表达的高阶抽象。</p>
<p>Stream API可以极大提高Java程序员的生产力，让程序员写出高效率、干净、简洁的代码。</p>
<p>这种风格将要处理的元素集合看作一种流， 流在管道中传输， 并且可以在管道的节点上进行处理， 比如筛选， 排序，聚合等。</p>
<p>元素流在管道中经过中间操作（intermediate operation）的处理，最后由最终操作(terminal operation)得到前面处理的结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">+--------------------+  +------+  +------+  +---+  +-------+  | stream of elements +-----&gt;  |filter+-&gt;  |sorted+-&gt;  |map+-&gt;  |collect|  +--------------------+  +------+  +------+  +---+  +-------+</span><br></pre></td></tr></table></figure></p>
<p>以上的流程转换为 Java 代码为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; transactionsIds = widgets.stream()  .filter(b -&gt; b.getColor()  == RED)  .sorted((x,y)  -&gt; x.getWeight()  - y.getWeight())  .mapToInt(Widget::getWeight)  .sum();</span><br></pre></td></tr></table></figure>
<hr>
<h2 id="什么是-Stream？"><a href="#什么是-Stream？" class="headerlink" title="什么是 Stream？"></a>什么是 Stream？</h2><p>Stream（流）是一个来自数据源的元素队列并支持聚合操作</p>
<ul>
<li>元素是特定类型的对象，形成一个队列。 Java中的Stream并不会存储元素，而是按需计算。</li>
<li><strong>数据源</strong> 流的来源。 可以是集合，数组，I/O channel， 产生器generator 等。</li>
<li><strong>聚合操作</strong> 类似SQL语句一样的操作， 比如filter, map, reduce, find, match, sorted等。</li>
</ul>
<p>和以前的Collection操作不同， Stream操作还有两个基础的特征：</p>
<ul>
<li><strong>Pipelining</strong>: 中间操作都会返回流对象本身。 这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。 这样做可以对操作进行优化， 比如延迟执行(laziness)和短路( short-circuiting)。</li>
<li><strong>内部迭代</strong>： 以前对集合遍历都是通过Iterator或者For-Each的方式, 显式的在集合外部进行迭代， 这叫做外部迭代。 Stream提供了内部迭代的方式， 通过访问者模式(Visitor)实现。</li>
</ul>
<hr>
<h2 id="生成流"><a href="#生成流" class="headerlink" title="生成流"></a>生成流</h2><p>在 Java 8 中, 集合接口有两个方法来生成流：</p>
<ul>
<li><p><strong>stream()</strong> − 为集合创建串行流。</p>
</li>
<li><p><strong>parallelStream()</strong> − 为集合创建并行流。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList());</span><br></pre></td></tr></table></figure>
</li>
</ul>
<hr>
<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p>Stream 提供了新的方法 ‘forEach’ 来迭代流中的每个数据。以下代码片段使用 forEach 输出了10个随机数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random  random = new  Random(); random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p>map 方法用于映射每个元素到对应的结果，以下代码片段使用 map 输出了元素对应的平方数：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); // 获取对应的平方数  List&lt;Integer&gt; squaresList = numbers.stream().map(  i -&gt; i*i).distinct().collect(Collectors.toList());</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h2><p>filter 方法用于通过设置的条件过滤出元素。以下代码片段使用 filter 方法过滤出空字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); // 获取空字符串的数量  int  count = strings.stream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><p>limit 方法用于获取指定数量的流。 以下代码片段使用 limit 方法打印出 10 条数据：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random  random = new  Random(); random.ints().limit(10).forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h2><p>sorted 方法用于对流进行排序。以下代码片段使用 sorted 方法对输出的 10 个随机数进行排序：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Random  random = new  Random(); random.ints().limit(10).sorted().forEach(System.out::println);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="并行（parallel）程序"><a href="#并行（parallel）程序" class="headerlink" title="并行（parallel）程序"></a>并行（parallel）程序</h2><p>parallelStream 是流并行处理程序的代替方法。以下实例我们使用 parallelStream 来输出空字符串的数量：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); // 获取空字符串的数量  int  count = strings.parallelStream().filter(string -&gt; string.isEmpty()).count();</span><br></pre></td></tr></table></figure></p>
<p>我们可以很容易的在顺序运行和并行直接切换。</p>
<hr>
<h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p>Collectors 类实现了很多归约操作，例如将流转换成集合和聚合元素。Collectors 可用于返回列表或字符串：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt;strings = Arrays.asList(&quot;abc&quot;, &quot;&quot;, &quot;bc&quot;, &quot;efg&quot;, &quot;abcd&quot;,&quot;&quot;, &quot;jkl&quot;); List&lt;String&gt; filtered = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.toList()); System.out.println(&quot;筛选列表: &quot; + filtered); String  mergedString = strings.stream().filter(string -&gt; !string.isEmpty()).collect(Collectors.joining(&quot;, &quot;)); System.out.println(&quot;合并字符串: &quot; + mergedString);</span><br></pre></td></tr></table></figure></p>
<hr>
<h2 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h2><p>另外，一些产生统计结果的收集器也非常有用。它们主要用于int、double、long等基本类型上，它们可以用来产生类似如下的统计结果。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; numbers = Arrays.asList(3, 2, 2, 3, 7, 3, 5); IntSummaryStatistics  stats = numbers.stream().mapToInt((x) -&gt; x).summaryStatistics(); System.out.println(&quot;列表中最大的数 : &quot; + stats.getMax()); System.out.println(&quot;列表中最小的数 : &quot; + stats.getMin()); System.out.println(&quot;所有数之和 : &quot; + stats.getSum()); System.out.println(&quot;平均数 : &quot; + stats.getAverage());</span><br></pre></td></tr></table></figure></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/Java 8stream/" data-id="cjyvgp27a000nswurgj2ajaga" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-wsdl" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/wsdl/" class="article-date">
  <time datetime="2019-04-16T06:34:08.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/wsdl/">WebService中的WSDL详解</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="WebService中的WSDL详解"><a href="#WebService中的WSDL详解" class="headerlink" title="WebService中的WSDL详解"></a>WebService中的WSDL详解</h3><pre><code>有人在WebService开发的时候，特别是和第三方有接口的时候，走的是SOAP协议，然后用户（或后台）给你一个WSDL文件（或网址），说按照上面的进行适配， 这时就要对WebService的WSDL有一定的理解，本文将对WSDL（WebService描述语言）进行详细总结。 
WSDL (Web Services Description Language,Web服务描述语言)是一种XML Application，他将Web服务描述定义为一组服务访问点，客户端可以通过这些服务访问点对包含面向文档信息或面向过程调用的服务进行访问(类似远程过程调用)。WSDL首先对访问的操作和访问时使用的请求/响应消息进行抽象描述，然后将其绑定到具体的传输协议和消息格式上以最终定义具体部署的服务访问点。相关的具体部署的服务访问点通过组合就成为抽象的Web服务。
</code></pre><p>一．WSDL的基本概念<br>       WSDL是一个用于精确描述Web服务的文档，WSDL文档是一个遵循WSDL-XML模式的XML文档。WSDL 文档将Web服务定义为服务访问点或端口的集合。在 WSDL 中，由于服务访问点和消息的抽象定义已从具体的服务部署或数据格式绑定中分离出来，因此可以对抽象定义进行再次使用。消息，指对交换数据的抽象描述；而端口类型，指操作的抽象集合。用于特定端口类型的具体协议和数据格式规范构成了可以再次使用的绑定。将Web访问地址与可再次使用的绑定相关联，可以定义一个端口，而端口的集合则定义为服务。<br>       一个WSDL文档通常包含8个重要的元素，即definitions、types、import、message、portType、operation、binding、service元素。这些元素嵌套在definitions元素中，definitions是WSDL文档的根元素。<br>WSDL文档外层结构图示：<br><img src="/2019/04/16/wsdl/1.png" alt="1"> </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">WSDL 服务进行交互的基本元素： </span><br><span class="line">Types（消息类型）：数据类型定义的容器，它使用某种类型系统（如 XSD）。 </span><br><span class="line">Message（消息）：通信数据的抽象类型化定义，它由一个或者多个 part 组成。 </span><br><span class="line">Part：消息参数 </span><br><span class="line">PortType（端口类型）：特定端口类型的具体协议和数据格式规范。，它由一个或者多个 Operation组成。 </span><br><span class="line">Operation（操作）：对服务所支持的操作进行抽象描述，WSDL定义了四种操作： </span><br><span class="line">1.单向（one-way）：端点接受信息； </span><br><span class="line">3.要求-响应（solicit-response）：端点发送消息，然后接受相关消息； </span><br><span class="line">4.通知（notification[2] ）：端点发送消息。</span><br><span class="line"></span><br><span class="line">Binding：特定端口类型的具体协议和数据格式规范。 </span><br><span class="line">Port：定义为绑定和网络地址组合的单个端点。 </span><br><span class="line">Service：相关端口的集合，包括其关联的接口、操作、消息等。 </span><br><span class="line">外层结构里面也可能有多层结构。</span><br></pre></td></tr></table></figure>
<p>二．WSDL的基本结构详解<br>下面通过一份wsdl文档，来详细解读WSDL结构：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;wsdl:definitions</span><br><span class="line">    targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;</span><br><span class="line">    xmlns:tns=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;</span><br><span class="line">    xmlns:wsdlsoap=&quot;http://schemas.xmlsoap.org/wsdl/soap/&quot;</span><br><span class="line">    xmlns:soap12=&quot;http://www.w3.org/2003/05/soap-envelope&quot;</span><br><span class="line">    xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">    xmlns:soapenc11=&quot;http://schemas.xmlsoap.org/soap/encoding/&quot;</span><br><span class="line">    xmlns:soapenc12=&quot;http://www.w3.org/2003/05/soap-encoding&quot;</span><br><span class="line">    xmlns:soap11=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;</span><br><span class="line">    xmlns:wsdl=&quot;http://schemas.xmlsoap.org/wsdl/&quot;&gt;</span><br><span class="line">    &lt;wsdl:types&gt;</span><br><span class="line">        &lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">            attributeFormDefault=&quot;qualified&quot; elementFormDefault=&quot;qualified&quot;</span><br><span class="line">            targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;&gt;</span><br><span class="line">            &lt;xsd:element name=&quot;sayHello&quot;&gt;</span><br><span class="line">                &lt;xsd:complexType&gt;</span><br><span class="line">                    &lt;xsd:sequence&gt;</span><br><span class="line">                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;</span><br><span class="line">                            name=&quot;name&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;</span><br><span class="line">                    &lt;/xsd:sequence&gt;</span><br><span class="line">                &lt;/xsd:complexType&gt;</span><br><span class="line">            &lt;/xsd:element&gt;</span><br><span class="line">            &lt;xsd:element name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">                &lt;xsd:complexType&gt;</span><br><span class="line">                    &lt;xsd:sequence&gt;</span><br><span class="line">                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot;</span><br><span class="line">                            name=&quot;return&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;</span><br><span class="line">                    &lt;/xsd:sequence&gt;</span><br><span class="line">                &lt;/xsd:complexType&gt;</span><br><span class="line">            &lt;/xsd:element&gt;</span><br><span class="line">        &lt;/xsd:schema&gt;</span><br><span class="line">    &lt;/wsdl:types&gt;</span><br><span class="line">    &lt;wsdl:message name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHelloResponse&quot; /&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line">    &lt;wsdl:message name=&quot;sayHelloRequest&quot;&gt;</span><br><span class="line">        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHello&quot; /&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line">    &lt;wsdl:portType name=&quot;HelloServicePortType&quot;&gt;</span><br><span class="line">        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;</span><br><span class="line">            &lt;wsdl:input name=&quot;sayHelloRequest&quot;</span><br><span class="line">                message=&quot;tns:sayHelloRequest&quot; /&gt;</span><br><span class="line">            &lt;wsdl:output name=&quot;sayHelloResponse&quot;</span><br><span class="line">                message=&quot;tns:sayHelloResponse&quot; /&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:portType&gt;</span><br><span class="line">    &lt;wsdl:binding name=&quot;HelloServiceHttpBinding&quot;</span><br><span class="line">        type=&quot;tns:HelloServicePortType&quot;&gt;</span><br><span class="line">        &lt;wsdlsoap:binding style=&quot;document&quot;</span><br><span class="line">            transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;</span><br><span class="line">        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;</span><br><span class="line">            &lt;wsdlsoap:operation soapAction=&quot;&quot; /&gt;</span><br><span class="line">            &lt;wsdl:input name=&quot;sayHelloRequest&quot;&gt;</span><br><span class="line">                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">            &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">            &lt;/wsdl:output&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:binding&gt;</span><br><span class="line">    &lt;wsdl:service name=&quot;HelloService&quot;&gt;</span><br><span class="line">        &lt;wsdl:port name=&quot;HelloServiceHttpPort&quot;</span><br><span class="line">            binding=&quot;tns:HelloServiceHttpBinding&quot;&gt;</span><br><span class="line">            &lt;wsdlsoap:address</span><br><span class="line">                location=&quot;http://localhost:8080/xfire/services/HelloService&quot; /&gt;</span><br><span class="line">        &lt;/wsdl:port&gt;</span><br><span class="line">    &lt;/wsdl:service&gt;</span><br><span class="line">&lt;/wsdl:definitions&gt;</span><br></pre></td></tr></table></figure>
<p>（一） definitions元素<br>       所有的WSDL文档的根元素均是definitions元素。该元素封装了整个文档，同时通过其name提供了一个WSDL文档。除了提供一个命名空间（targetNamespace）外，该元素没有其他作用，故不作详细描述。</p>
<p>（二）types元素<br>       WSDL采用了W3C XML模式内置类型作为其基本类型系统。types元素用作一个容器，用于定义XML模式内置类型中没有描述的各种数据类型（不太明白：XML模式内置类型中没有描述的各种数据类型）。当声明消息部分的有效时，消息定义使用了在types元素中定义的数据类型和元素。在本文的WSDL文档中的types定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:types&gt;</span><br><span class="line">        &lt;xsd:schema xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;</span><br><span class="line">            attributeFormDefault=&quot;qualified&quot; elementFormDefault=&quot;qualified&quot;</span><br><span class="line">            targetNamespace=&quot;http://com.liuxiang.xfireDemo/HelloService&quot;&gt;</span><br><span class="line">            &lt;xsd:element name=&quot;sayHello&quot;&gt;</span><br><span class="line">                &lt;xsd:complexType&gt;</span><br><span class="line">                    &lt;xsd:sequence&gt;</span><br><span class="line">                        &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;1&quot;</span><br><span class="line">                            name=&quot;name&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;</span><br><span class="line">                    &lt;/xsd:sequence&gt;</span><br><span class="line">                &lt;/xsd:complexType&gt;</span><br><span class="line">            &lt;/xsd:element&gt;</span><br><span class="line">            &lt;xsd:element name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">                &lt;xsd:complexType&gt;</span><br><span class="line">                    &lt;xsd:sequence&gt;</span><br><span class="line">                          &lt;xsd:element maxOccurs=&quot;1&quot; minOccurs=&quot;0&quot;</span><br><span class="line">                            name=&quot;return&quot; nillable=&quot;true&quot; type=&quot;xsd:string&quot; /&gt;</span><br><span class="line">                    &lt;/xsd:sequence&gt;</span><br><span class="line">                &lt;/xsd:complexType&gt;</span><br><span class="line">            &lt;/xsd:element&gt;</span><br><span class="line">        &lt;/xsd:schema&gt;</span><br><span class="line">    &lt;/wsdl:types&gt;</span><br><span class="line"></span><br><span class="line">       上面是数据定义部分，该部分定义了两个元素，一个是sayHello，一个是sayHelloResponse： </span><br><span class="line">       sayHello：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的参入传入部分； </span><br><span class="line">       sayHelloResponse：定义了一个复杂类型，仅仅包含一个简单的字符串，将来用来描述操作的返回值； </span><br><span class="line">       这里sayHelloResponse是和sayHello相关的，sayHello相对于一个方法，里面的： type=”xsd:string”，name=”name”，是确定传入name的参数是String类型的，而sayHelloResponse中的 name=”return” type=”xsd:string” 是确定方法sayHello（String name）返回的类型是String类型的。</span><br></pre></td></tr></table></figure></p>
<p>（三）import元素<br>       import元素使得可以在当前的WSDL文档中使用其他WSDL文档中指定的命名空间中的定义元素。本例子中没有使用import元素。通常在用户希望模块化WSDL文档的时候，该功能是非常有效果的。<br>import的格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:import namespace=&quot;http://xxx.xxx.xxx/xxx/xxx&quot; location=&quot;http://xxx.xxx.xxx/xxx/xxx.wsdl&quot;/&gt;</span><br></pre></td></tr></table></figure></p>
<p>必须有namespace属性和location属性：<br>1.namespace属性：值必须与正导入的WSDL文档中声明的targetNamespace相匹配；<br>2.location属性：必须指向一个实际的WSDL文档，并且该文档不能为空。</p>
<p>（四）message元素<br>       message元素描述了Web服务使用消息的有效负载。message元素可以描述输出或者接受消息的有效负载；还可以描述SOAP文件头和错误detail元素的内容。定义message元素的方式取决于使用RPC样式还是文档样式的消息传递。在本文中的message元素的定义，本文档使用了采用文档样式的消息传递：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:message name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHelloResponse&quot; /&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br><span class="line">    &lt;wsdl:message name=&quot;sayHelloRequest&quot;&gt;</span><br><span class="line">        &lt;wsdl:part name=&quot;parameters&quot; element=&quot;tns:sayHello&quot; /&gt;</span><br><span class="line">    &lt;/wsdl:message&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>该部分是消息格式的抽象定义：定义了两个消息sayHelloResponse和sayHelloRequest：
</code></pre><p>1.sayHelloRequest：<br>sayHello操作的请求消息格式，由一个消息片断组成，名字为parameters,元素是我们前面定义的types中的元素；</p>
<p>2.sayHelloResponse：<br>sayHello操作的响应消息格式，由一个消息片断组成，名字为parameters,元素是我们前面定义的types中的元素；<br>        如果采用RPC样式的消息传递，只需要将文档中的element元素修改为type即可（？？）。</p>
<p>（五）portType元素<br>       portType元素定义了Web服务的抽象接口。该接口有点类似Java的接口，都是定义了一个抽象类型和方法，没有定义实现。在WSDL中，portType元素是由binding和service元素来实现的，这两个元素用来说明Web服务实现使用的Internet协议、编码方案以及Internet地址。<br>一个portType中可以定义多个operation，一个operation可以看作是一个方法，本文中WSDL文档的定义：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:portType name=&quot;HelloServicePortType&quot;&gt;</span><br><span class="line">        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;</span><br><span class="line">            &lt;wsdl:input name=&quot;sayHelloRequest&quot;</span><br><span class="line">                message=&quot;tns:sayHelloRequest&quot; /&gt;</span><br><span class="line">            &lt;wsdl:output name=&quot;sayHelloResponse&quot;</span><br><span class="line">                message=&quot;tns:sayHelloResponse&quot; /&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:portType&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>portType定义了服务的调用模式的类型，这里包含一个操作sayHello方法，同时包含input和output表明该操作是一个请求／响应模式，请求消息是前面定义的sayHelloRequest，响应消息是前面定义的sayHelloResponse。input表示传递到Web服务的有效负载，output消息表示传递给客户的有效负载。 
   这里相当于抽象类中定义了一个抽象方法sayHello，而方法参数的定义和返回值的定义都是在types中设置的，方法名又是在message中定义有的。
</code></pre><p>（六）binding<br>       binding元素将一个抽象portType映射到一组具体协议(SOAO和HTTP)、消息传递样式、编码样式。通常binding元素与协议专有的元素和在一起使用，本文中的例子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:binding name=&quot;HelloServiceHttpBinding&quot;</span><br><span class="line">        type=&quot;tns:HelloServicePortType&quot;&gt;</span><br><span class="line">        &lt;wsdlsoap:binding style=&quot;document&quot;</span><br><span class="line">            transport=&quot;http://schemas.xmlsoap.org/soap/http&quot; /&gt;</span><br><span class="line">        &lt;wsdl:operation name=&quot;sayHello&quot;&gt;</span><br><span class="line">            &lt;wsdlsoap:operation soapAction=&quot;&quot; /&gt;</span><br><span class="line">            &lt;wsdl:input name=&quot;sayHelloRequest&quot;&gt;</span><br><span class="line">                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">            &lt;/wsdl:input&gt;</span><br><span class="line">            &lt;wsdl:output name=&quot;sayHelloResponse&quot;&gt;</span><br><span class="line">                &lt;wsdlsoap:body use=&quot;literal&quot; /&gt;</span><br><span class="line">            &lt;/wsdl:output&gt;</span><br><span class="line">        &lt;/wsdl:operation&gt;</span><br><span class="line">    &lt;/wsdl:binding&gt;</span><br></pre></td></tr></table></figure></p>
<pre><code>这部分将服务访问点的抽象定义与SOAP、HTTP绑定，描述如何通过SOAP/HTTP来访问按照前面描述的访问入口点类型部署的访问入口。 
</code></pre><p>其中规定了在具体SOAP调用时，应当使用的soapAction是”xxx”，这个Action在WebService代码调用中是很重要的。具体的使用需要参考特定协议定义的元素。</p>
<p>（七）service元素和port元素<br>       service元素包含一个或者多个port元素，其中每个port元素表示一个不同的Web服务。port元素将URL赋给一个特定的binding，甚至可以使两个或者多个port元素将不同的URL赋值给相同的binding。文档中的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;wsdl:service name=&quot;HelloService&quot;&gt;</span><br><span class="line">        &lt;wsdl:port name=&quot;HelloServiceHttpPort&quot;</span><br><span class="line">            binding=&quot;tns:HelloServiceHttpBinding&quot;&gt;</span><br><span class="line">            &lt;wsdlsoap:address</span><br><span class="line">                location=&quot;http://localhost:8080/xfire/services/HelloService&quot; /&gt;</span><br><span class="line">        &lt;/wsdl:port&gt;</span><br><span class="line">    &lt;/wsdl:service&gt;</span><br></pre></td></tr></table></figure>
<pre><code>对于这个WSDL文档的学习，第一次看是感觉非常陌生的，而且里面元素又多，学习的话先是要了解外层结构代表的意义和作用，然后理解里面的元素的意义和作用，有些元素作用不大，有些元素又是很关联的，有些元素是比较重要的。 
</code></pre><p>WSDL图解：<br><img src="/2019/04/16/wsdl/2.png" alt="2"><br><img src="/2019/04/16/wsdl/3.png" alt="3"></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/wsdl/" data-id="cjyvgp28j001kswuretxzkb79" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-跨域" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/跨域/" class="article-date">
  <time datetime="2019-04-16T03:53:08.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/16/跨域/">跨域</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="什么是跨域？"><a href="#什么是跨域？" class="headerlink" title="什么是跨域？"></a><strong>什么是跨域？</strong></h3><p>跨域是指一个域下的文档或脚本试图去请求另一个域下的资源，这里跨域是广义的。</p>
<p>广义的跨域：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.) 资源跳转： A链接、重定向、表单提交</span><br><span class="line">2.) 资源嵌入： &lt;link&gt;、&lt;script&gt;、&lt;img&gt;、&lt;frame&gt;等dom标签，还有样式中background:url()、@font-face()等文件外链</span><br><span class="line">3.) 脚本请求： js发起的ajax请求、dom和js对象的跨域操作等</span><br></pre></td></tr></table></figure>
<p>其实我们通常所说的跨域是狭义的，是由浏览器同源策略限制的一类请求场景。</p>
<p><strong>什么是同源策略？</strong><br>同源策略/SOP（Same origin policy）是一种约定，由Netscape公司1995年引入浏览器，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，浏览器很容易受到XSS、CSFR等攻击。所谓同源是指”协议+域名+端口”三者相同，即便两个不同的域名指向同一个ip地址，也非同源。</p>
<p>同源策略限制以下几种行为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.) Cookie、LocalStorage 和 IndexDB 无法读取</span><br><span class="line">2.) DOM 和 Js对象无法获得</span><br><span class="line">3.) AJAX 请求不能发送</span><br></pre></td></tr></table></figure>
<h3 id="常见跨域场景"><a href="#常见跨域场景" class="headerlink" title="常见跨域场景"></a><strong>常见跨域场景</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">URL                                      说明                    是否允许通信</span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同文件或路径           允许</span><br><span class="line">http://www.domain.com/lab/c.js</span><br><span class="line"></span><br><span class="line">http://www.domain.com:8000/a.js</span><br><span class="line">http://www.domain.com/b.js         同一域名，不同端口                不允许</span><br><span class="line"></span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">https://www.domain.com/b.js        同一域名，不同协议                不允许</span><br><span class="line"></span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://192.168.4.12/b.js           域名和域名对应相同ip              不允许</span><br><span class="line"></span><br><span class="line">http://www.domain.com/a.js</span><br><span class="line">http://x.domain.com/b.js           主域相同，子域不同                不允许</span><br><span class="line">http://domain.com/c.js</span><br><span class="line"></span><br><span class="line">http://www.domain1.com/a.js</span><br><span class="line">http://www.domain2.com/b.js        不同域名                         不允许</span><br></pre></td></tr></table></figure>
<h3 id="跨域解决方案"><a href="#跨域解决方案" class="headerlink" title="跨域解决方案"></a><strong>跨域解决方案</strong></h3><p>1、 通过jsonp跨域<br>2、 document.domain + iframe跨域<br>3、 location.hash + iframe<br>4、 window.name + iframe跨域<br>5、 postMessage跨域<br>6、 跨域资源共享（CORS）<br>7、 nginx代理跨域<br>8、 nodejs中间件代理跨域<br>9、 WebSocket协议跨域</p>
<h4 id="一、-通过jsonp跨域"><a href="#一、-通过jsonp跨域" class="headerlink" title="一、 通过jsonp跨域"></a><strong>一、 通过jsonp跨域</strong></h4><p>通常为了减轻web服务器的负载，我们把js、css，img等静态资源分离到另一台独立域名的服务器上，在html页面中再通过相应的标签从不同域名下加载静态资源，而被浏览器允许，基于此原理，我们可以通过动态创建script，再请求一个带参网址实现跨域通信。</p>
<p>1.）原生实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">   var script = document.createElement(&apos;script&apos;);</span><br><span class="line">   script.type = &apos;text/javascript&apos;;</span><br><span class="line"></span><br><span class="line">   // 传参并指定回调执行函数为onBack</span><br><span class="line">   script.src = &apos;http://www.domain2.com:8080/login?user=admin&amp;callback=onBack&apos;;</span><br><span class="line">   document.head.appendChild(script);</span><br><span class="line"></span><br><span class="line">   // 回调执行函数</span><br><span class="line">   function onBack(res) &#123;</span><br><span class="line">       alert(JSON.stringify(res));</span><br><span class="line">   &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">onBack(&#123;&quot;status&quot;: true, &quot;user&quot;: &quot;admin&quot;&#125;)</span><br></pre></td></tr></table></figure>
<p>2.）jquery ajax：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url: &apos;http://www.domain2.com:8080/login&apos;,</span><br><span class="line">    type: &apos;get&apos;,</span><br><span class="line">    dataType: &apos;jsonp&apos;,  // 请求方式为jsonp</span><br><span class="line">    jsonpCallback: &quot;onBack&quot;,    // 自定义回调函数名</span><br><span class="line">    data: &#123;&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.）vue.js：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this.$http.jsonp(&apos;http://www.domain2.com:8080/login&apos;, &#123;</span><br><span class="line">    params: &#123;&#125;,</span><br><span class="line">    jsonp: &apos;onBack&apos;</span><br><span class="line">&#125;).then((res) =&gt; &#123;</span><br><span class="line">    console.log(res); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>后端node.js代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var querystring = require(&apos;querystring&apos;);</span><br><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.split(&apos;?&apos;)[1]);</span><br><span class="line">    var fn = params.callback;</span><br><span class="line"></span><br><span class="line">    // jsonp返回设置</span><br><span class="line">    res.writeHead(200, &#123; &apos;Content-Type&apos;: &apos;text/javascript&apos; &#125;);</span><br><span class="line">    res.write(fn + &apos;(&apos; + JSON.stringify(params) + &apos;)&apos;);</span><br><span class="line"></span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure>
<p>jsonp缺点：只能实现get一种请求。</p>
<h4 id="二、-document-domain-iframe跨域"><a href="#二、-document-domain-iframe跨域" class="headerlink" title="二、 document.domain + iframe跨域"></a><strong>二、 document.domain + iframe跨域</strong></h4><p>此方案仅限主域相同，子域不同的跨域应用场景。</p>
<p>实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1.）父窗口：(<a href="http://www.domain.com/a.html" target="_blank" rel="noopener">http://www.domain.com/a.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://child.domain.com/b.html&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;domain.com&apos;;</span><br><span class="line">    var user = &apos;admin&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.）子窗口：(<a href="http://child.domain.com/b.html" target="_blank" rel="noopener">http://child.domain.com/b.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    document.domain = &apos;domain.com&apos;;</span><br><span class="line">    // 获取父窗口中变量</span><br><span class="line">    alert(&apos;get js data from parent ---&gt; &apos; + window.parent.user);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="三、-location-hash-iframe跨域"><a href="#三、-location-hash-iframe跨域" class="headerlink" title="三、 location.hash + iframe跨域"></a><strong>三、 location.hash + iframe跨域</strong></h4><p>实现原理： a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 向b.html传hash值</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        iframe.src = iframe.src + &apos;#user=admin&apos;;</span><br><span class="line">    &#125;, 1000);</span><br><span class="line"></span><br><span class="line">    // 开放给同域c.html的回调方法</span><br><span class="line">    function onCallback(res) &#123;</span><br><span class="line">        alert(&apos;data from c.html ---&gt; &apos; + res);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain1.com/c.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 监听a.html传来的hash值，再传给c.html</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        iframe.src = iframe.src + location.hash;</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>3.）c.html：(<a href="http://www.domain1.com/c.html" target="_blank" rel="noopener">http://www.domain1.com/c.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 监听b.html传来的hash值</span><br><span class="line">    window.onhashchange = function () &#123;</span><br><span class="line">        // 再通过操作同域a.html的js回调，将结果传回</span><br><span class="line">        window.parent.parent.onCallback(&apos;hello: &apos; + location.hash.replace(&apos;#user=&apos;, &apos;&apos;));</span><br><span class="line">    &#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="四、-window-name-iframe跨域"><a href="#四、-window-name-iframe跨域" class="headerlink" title="四、 window.name + iframe跨域"></a><strong>四、 window.name + iframe跨域</strong></h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">var proxy = function(url, callback) &#123;</span><br><span class="line">    var state = 0;</span><br><span class="line">    var iframe = document.createElement(&apos;iframe&apos;);</span><br><span class="line"></span><br><span class="line">    // 加载跨域页面</span><br><span class="line">    iframe.src = url;</span><br><span class="line"></span><br><span class="line">    // onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        if (state === 1) &#123;</span><br><span class="line">            // 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br><span class="line">            callback(iframe.contentWindow.name);</span><br><span class="line">            destoryFrame();</span><br><span class="line"></span><br><span class="line">        &#125; else if (state === 0) &#123;</span><br><span class="line">            // 第1次onload(跨域页)成功后，切换到同域代理页面</span><br><span class="line">            iframe.contentWindow.location = &apos;http://www.domain1.com/proxy.html&apos;;</span><br><span class="line">            state = 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    document.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">    // 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br><span class="line">    function destoryFrame() &#123;</span><br><span class="line">        iframe.contentWindow.document.write(&apos;&apos;);</span><br><span class="line">        iframe.contentWindow.close();</span><br><span class="line">        document.body.removeChild(iframe);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// 请求跨域b页面数据</span><br><span class="line">proxy(&apos;http://www.domain2.com/b.html&apos;, function(data)&#123;</span><br><span class="line">    alert(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>2.）proxy.html：(<a href="http://www.domain1.com/proxy.html" target="_blank" rel="noopener">http://www.domain1.com/proxy….</a>)<br>中间代理页，与a.html同域，内容为空即可。</p>
<p>3.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    window.name = &apos;This is domain2 data!&apos;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>总结：通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="五、-postMessage跨域"><a href="#五、-postMessage跨域" class="headerlink" title="五、 postMessage跨域"></a><strong>五、 postMessage跨域</strong></h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：<br>a.） 页面和其打开的新窗口的数据传递<br>b.） 多窗口之间消息传递<br>c.） 页面与嵌套的iframe消息传递<br>d.） 上面三个场景的跨域数据传递</p>
<p>用法：postMessage(data,origin)方法接受两个参数<br>data： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。<br>origin： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”/“。</p>
<p>1.）a.html：(<a href="http://www.domain1.com/a.html" target="_blank" rel="noopener">http://www.domain1.com/a.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;iframe id=&quot;iframe&quot; src=&quot;http://www.domain2.com/b.html&quot; style=&quot;display:none;&quot;&gt;&lt;/iframe&gt;</span><br><span class="line">&lt;script&gt;       </span><br><span class="line">    var iframe = document.getElementById(&apos;iframe&apos;);</span><br><span class="line">    iframe.onload = function() &#123;</span><br><span class="line">        var data = &#123;</span><br><span class="line">            name: &apos;aym&apos;</span><br><span class="line">        &#125;;</span><br><span class="line">        // 向domain2传送跨域数据</span><br><span class="line">        iframe.contentWindow.postMessage(JSON.stringify(data), &apos;http://www.domain2.com&apos;);</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 接受domain2返回数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain2 ---&gt; &apos; + e.data);</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.）b.html：(<a href="http://www.domain2.com/b.html" target="_blank" rel="noopener">http://www.domain2.com/b.html)</a>)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    // 接收domain1的数据</span><br><span class="line">    window.addEventListener(&apos;message&apos;, function(e) &#123;</span><br><span class="line">        alert(&apos;data from domain1 ---&gt; &apos; + e.data);</span><br><span class="line"></span><br><span class="line">        var data = JSON.parse(e.data);</span><br><span class="line">        if (data) &#123;</span><br><span class="line">            data.number = 16;</span><br><span class="line"></span><br><span class="line">            // 处理后再发回domain1</span><br><span class="line">            window.parent.postMessage(JSON.stringify(data), &apos;http://www.domain1.com&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, false);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="六、-跨域资源共享（CORS）"><a href="#六、-跨域资源共享（CORS）" class="headerlink" title="六、 跨域资源共享（CORS）"></a><strong>六、 跨域资源共享（CORS）</strong></h4><p>普通跨域请求：只服务端设置Access-Control-Allow-Origin即可，前端无须设置，若要带cookie请求：前后端都需要设置。</p>
<p>需注意的是：由于同源策略的限制，所读取的cookie为跨域请求接口所在域的cookie，而非当前页。如果想实现当前页cookie的写入，可参考下文：七、nginx反向代理中设置proxy_cookie_domain 和 八、NodeJs中间件代理中cookieDomainRewrite参数的设置。</p>
<p>目前，所有浏览器都支持该功能(IE8+：IE8/9需要使用XDomainRequest对象来支持CORS）)，CORS也已经成为主流的跨域解决方案。</p>
<h5 id="1、-前端设置："><a href="#1、-前端设置：" class="headerlink" title="1、 前端设置："></a><strong>1、 前端设置：</strong></h5><p>1.）原生ajax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br></pre></td></tr></table></figure>
<p>示例代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest(); // IE8/9需用window.XDomainRequest兼容</span><br><span class="line"></span><br><span class="line">// 前端设置是否带cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">xhr.open(&apos;post&apos;, &apos;http://www.domain2.com:8080/login&apos;, true);</span><br><span class="line">xhr.setRequestHeader(&apos;Content-Type&apos;, &apos;application/x-www-form-urlencoded&apos;);</span><br><span class="line">xhr.send(&apos;user=admin&apos;);</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange = function() &#123;</span><br><span class="line">    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123;</span><br><span class="line">        alert(xhr.responseText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.）jQuery ajax</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    ...</span><br><span class="line">   xhrFields: &#123;</span><br><span class="line">       withCredentials: true    // 前端设置是否带cookie</span><br><span class="line">   &#125;,</span><br><span class="line">   crossDomain: true,   // 会让请求头中包含跨域的额外信息，但不会含cookie</span><br><span class="line">    ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>3.）vue框架</p>
<p>a.) axios设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">axios.defaults.withCredentials = true</span><br></pre></td></tr></table></figure>
<p>b.) vue-resource设置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Vue.http.options.credentials = true</span><br></pre></td></tr></table></figure>
<h5 id="2、-服务端设置："><a href="#2、-服务端设置：" class="headerlink" title="2、 服务端设置："></a><strong>2、 服务端设置：</strong></h5><p>若后端设置成功，前端浏览器控制台则不会出现跨域报错信息，反之，说明没设成功。</p>
<p>1.）Java后台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * 导入包：import javax.servlet.http.HttpServletResponse;</span><br><span class="line"> * 接口参数中定义：HttpServletResponse response</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">// 允许跨域访问的域名：若有端口需写全（协议+域名+端口），若没有端口末尾不用加&apos;/&apos;</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Origin&quot;, &quot;http://www.domain1.com&quot;); </span><br><span class="line"></span><br><span class="line">// 允许前端带认证cookie：启用此项后，上面的域名不能为&apos;*&apos;，必须指定具体的域名，否则浏览器会提示</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Credentials&quot;, &quot;true&quot;); </span><br><span class="line"></span><br><span class="line">// 提示OPTIONS预检时，后端需要设置的两个常用自定义头</span><br><span class="line">response.setHeader(&quot;Access-Control-Allow-Headers&quot;, &quot;Content-Type,X-Requested-With&quot;);</span><br></pre></td></tr></table></figure>
<p>2.）Nodejs后台示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var postData = &apos;&apos;;</span><br><span class="line"></span><br><span class="line">    // 数据块接收中</span><br><span class="line">    req.addListener(&apos;data&apos;, function(chunk) &#123;</span><br><span class="line">        postData += chunk;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 数据接收完毕</span><br><span class="line">    req.addListener(&apos;end&apos;, function() &#123;</span><br><span class="line">        postData = qs.parse(postData);</span><br><span class="line"></span><br><span class="line">        // 跨域后台设置</span><br><span class="line">        res.writeHead(200, &#123;</span><br><span class="line">            &apos;Access-Control-Allow-Credentials&apos;: &apos;true&apos;,     // 后端允许发送Cookie</span><br><span class="line">            &apos;Access-Control-Allow-Origin&apos;: &apos;http://www.domain1.com&apos;,    // 允许访问的域（协议+域名+端口）</span><br><span class="line">            /* </span><br><span class="line">             * 此处设置的cookie还是domain2的而非domain1，因为后端也不能跨域写cookie(nginx反向代理可以实现)，</span><br><span class="line">             * 但只要domain2中写入一次cookie认证，后面的跨域接口都能从domain2中获取cookie，从而实现所有的接口都能跨域访问</span><br><span class="line">             */</span><br><span class="line">            &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;  // HttpOnly的作用是让js无法读取cookie</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        res.write(JSON.stringify(postData));</span><br><span class="line">        res.end();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="七、-nginx代理跨域"><a href="#七、-nginx代理跨域" class="headerlink" title="七、 nginx代理跨域"></a><strong>七、 nginx代理跨域</strong></h4><h5 id="1、-nginx配置解决iconfont跨域"><a href="#1、-nginx配置解决iconfont跨域" class="headerlink" title="1、 nginx配置解决iconfont跨域"></a><strong>1、 nginx配置解决iconfont跨域</strong></h5><p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  add_header Access-Control-Allow-Origin *;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、-nginx反向代理接口跨域"><a href="#2、-nginx反向代理接口跨域" class="headerlink" title="2、 nginx反向代理接口跨域"></a><strong>2、 nginx反向代理接口跨域</strong></h5><p>跨域原理： 同源策略是浏览器的安全策略，不是HTTP协议的一部分。服务器端调用HTTP接口只是使用HTTP协议，不会执行JS脚本，不需要同源策略，也就不存在跨越问题。</p>
<p>实现思路：通过nginx配置一个代理服务器（域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域登录。</p>
<p>nginx具体配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#proxy服务器</span><br><span class="line">server &#123;</span><br><span class="line">    listen       81;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line"></span><br><span class="line">    location / &#123;</span><br><span class="line">        proxy_pass   http://www.domain2.com:8080;  #反向代理</span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http://www.domain1.com;  #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>1.) 前端代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问nginx中的代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:81/?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>2.) Nodejs后台示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var server = http.createServer();</span><br><span class="line">var qs = require(&apos;querystring&apos;);</span><br><span class="line"></span><br><span class="line">server.on(&apos;request&apos;, function(req, res) &#123;</span><br><span class="line">    var params = qs.parse(req.url.substring(2));</span><br><span class="line"></span><br><span class="line">    // 向前台写cookie</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Set-Cookie&apos;: &apos;l=a123456;Path=/;Domain=www.domain2.com;HttpOnly&apos;   // HttpOnly:脚本无法读取</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    res.write(JSON.stringify(params));</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br></pre></td></tr></table></figure>
<h4 id="八、-Nodejs中间件代理跨域"><a href="#八、-Nodejs中间件代理跨域" class="headerlink" title="八、 Nodejs中间件代理跨域"></a><strong>八、 Nodejs中间件代理跨域</strong></h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<h5 id="1、-非vue框架的跨域（2次跨域）"><a href="#1、-非vue框架的跨域（2次跨域）" class="headerlink" title="1、 非vue框架的跨域（2次跨域）"></a><strong>1、 非vue框架的跨域（2次跨域）</strong></h5><p>利用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<p>1.）前端代码示例：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr = new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">// 前端开关：浏览器是否读写cookie</span><br><span class="line">xhr.withCredentials = true;</span><br><span class="line"></span><br><span class="line">// 访问http-proxy-middleware代理服务器</span><br><span class="line">xhr.open(&apos;get&apos;, &apos;http://www.domain1.com:3000/login?user=admin&apos;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>
<p>2.）中间件服务器：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var express = require(&apos;express&apos;);</span><br><span class="line">var proxy = require(&apos;http-proxy-middleware&apos;);</span><br><span class="line">var app = express();</span><br><span class="line"></span><br><span class="line">app.use(&apos;/&apos;, proxy(&#123;</span><br><span class="line">    // 代理跨域目标接口</span><br><span class="line">    target: &apos;http://www.domain2.com:8080&apos;,</span><br><span class="line">    changeOrigin: true,</span><br><span class="line"></span><br><span class="line">    // 修改响应头信息，实现跨域并允许带cookie</span><br><span class="line">    onProxyRes: function(proxyRes, req, res) &#123;</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Origin&apos;, &apos;http://www.domain1.com&apos;);</span><br><span class="line">        res.header(&apos;Access-Control-Allow-Credentials&apos;, &apos;true&apos;);</span><br><span class="line">    &#125;,</span><br><span class="line"></span><br><span class="line">    // 修改响应信息中的cookie域名</span><br><span class="line">    cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">&#125;));</span><br><span class="line"></span><br><span class="line">app.listen(3000);</span><br><span class="line">console.log(&apos;Proxy server is listen at port 3000...&apos;);</span><br></pre></td></tr></table></figure>
<p>3.）Nodejs后台同（六：nginx）</p>
<h5 id="2、-vue框架的跨域（1次跨域）"><a href="#2、-vue框架的跨域（1次跨域）" class="headerlink" title="2、 vue框架的跨域（1次跨域）"></a><strong>2、 vue框架的跨域（1次跨域）</strong></h5><p>利用node + webpack + webpack-dev-server代理接口跨域。在开发环境下，由于vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域，无须设置headers跨域信息了。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">module.exports = &#123;</span><br><span class="line">    entry: &#123;&#125;,</span><br><span class="line">    module: &#123;&#125;,</span><br><span class="line">    ...</span><br><span class="line">    devServer: &#123;</span><br><span class="line">        historyApiFallback: true,</span><br><span class="line">        proxy: [&#123;</span><br><span class="line">            context: &apos;/login&apos;,</span><br><span class="line">            target: &apos;http://www.domain2.com:8080&apos;,  // 代理跨域目标接口</span><br><span class="line">            changeOrigin: true,</span><br><span class="line">            secure: false,  // 当代理某些https服务报错时用</span><br><span class="line">            cookieDomainRewrite: &apos;www.domain1.com&apos;  // 可以为false，表示不修改</span><br><span class="line">        &#125;],</span><br><span class="line">        noInfo: true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="九、-WebSocket协议跨域"><a href="#九、-WebSocket协议跨域" class="headerlink" title="九、 WebSocket协议跨域"></a>九、 WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。<br>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1.）前端代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;user input：&lt;input type=&quot;text&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script src=&quot;./socket.io.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var socket = io(&apos;http://www.domain2.com:8080&apos;);</span><br><span class="line"></span><br><span class="line">// 连接成功处理</span><br><span class="line">socket.on(&apos;connect&apos;, function() &#123;</span><br><span class="line">    // 监听服务端消息</span><br><span class="line">    socket.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        console.log(&apos;data from server: ---&gt; &apos; + msg); </span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 监听服务端关闭</span><br><span class="line">    socket.on(&apos;disconnect&apos;, function() &#123; </span><br><span class="line">        console.log(&apos;Server socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">document.getElementsByTagName(&apos;input&apos;)[0].onblur = function() &#123;</span><br><span class="line">    socket.send(this.value);</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>2.）Nodejs socket后台：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var http = require(&apos;http&apos;);</span><br><span class="line">var socket = require(&apos;socket.io&apos;);</span><br><span class="line"></span><br><span class="line">// 启http服务</span><br><span class="line">var server = http.createServer(function(req, res) &#123;</span><br><span class="line">    res.writeHead(200, &#123;</span><br><span class="line">        &apos;Content-type&apos;: &apos;text/html&apos;</span><br><span class="line">    &#125;);</span><br><span class="line">    res.end();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.listen(&apos;8080&apos;);</span><br><span class="line">console.log(&apos;Server is running at port 8080...&apos;);</span><br><span class="line"></span><br><span class="line">// 监听socket连接</span><br><span class="line">socket.listen(server).on(&apos;connection&apos;, function(client) &#123;</span><br><span class="line">    // 接收信息</span><br><span class="line">    client.on(&apos;message&apos;, function(msg) &#123;</span><br><span class="line">        client.send(&apos;hello：&apos; + msg);</span><br><span class="line">        console.log(&apos;data from client: ---&gt; &apos; + msg);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    // 断开处理</span><br><span class="line">    client.on(&apos;disconnect&apos;, function() &#123;</span><br><span class="line">        console.log(&apos;Client socket has closed.&apos;); </span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/跨域/" data-id="cjyvgp2a1001pswurflxgb97b" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-springboot日志框架" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/springboot日志框架/" class="article-date">
  <time datetime="2019-04-15T10:53:08.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/springboot日志框架/">springboot的logback日志框架</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天来介绍下Spring Boot如何配置日志logback,我刚学习的时候，是带着下面几个问题来查资料的，你呢</p>
<ul>
<li><p>如何引入日志？</p>
</li>
<li><p>日志输出格式以及输出方式如何配置？</p>
</li>
<li><p>代码中如何使用？</p>
</li>
</ul>
<h1 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h1><p>Spring Boot在所有内部日志中使用Commons Logging，但是默认配置也提供了对常用日志的支持，如：Java Util Logging，Log4J, Log4J2和Logback。每种Logger都可以通过配置使用控制台或者文件输出日志内容。</p>
<h1 id="默认日志Logback"><a href="#默认日志Logback" class="headerlink" title="默认日志Logback"></a>默认日志Logback</h1><p>SLF4J——Simple Logging Facade For Java，它是一个针对于各类Java日志框架的统一Facade抽象。Java日志框架众多——常用的有java.util.logging, log4j, logback，commons-logging, Spring框架使用的是Jakarta Commons Logging API (JCL)。而SLF4J定义了统一的日志抽象接口，而真正的日志实现则是在运行时决定的——它提供了各类日志框架的binding。</p>
<p>Logback是log4j框架的作者开发的新一代日志框架，它效率更高、能够适应诸多的运行环境，同时天然支持SLF4J。</p>
<p>默认情况下，Spring Boot会用Logback来记录日志，并用INFO级别输出到控制台。在运行应用程序和其他例子时，你应该已经看到很多INFO级别的日志了。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZYW24kug9wHcKcRIHbPvxfEcmxicDqjKuEYOiaabWPEAlOKgPXYu3ziaJQ/0?wx_fmt=jpeg" alt></p>
<p>从上图可以看到，日志输出内容元素具体如下：</p>
<ul>
<li><p>时间日期：精确到毫秒</p>
</li>
<li><p>日志级别：ERROR, WARN, INFO, DEBUG or TRACE</p>
</li>
<li><p>进程ID</p>
</li>
<li><p>分隔符：— 标识实际日志的开始</p>
</li>
<li><p>线程名：方括号括起来（可能会截断控制台输出）</p>
</li>
<li><p>Logger名：通常使用源代码的类名</p>
</li>
<li><p>日志内容</p>
</li>
</ul>
<h1 id="添加日志依赖"><a href="#添加日志依赖" class="headerlink" title="添加日志依赖"></a>添加日志依赖</h1><p>假如maven依赖中添加了spring-boot-starter-logging：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZnckFFXukjFmPeem88BF8118XEZF550YA8hu11LIqCC2UN6n2odGicQw/0?wx_fmt=jpeg" alt></p>
<p>那么，我们的Spring Boot应用将自动使用logback作为应用日志框架，Spring Boot启动的时候，由org.springframework.boot.logging.Logging-Application-Listener根据情况初始化并使用。</p>
<p>但是呢，实际开发中我们不需要直接添加该依赖，你会发现spring-boot-starter其中包含了 spring-boot-starter-logging，该依赖内容就是 Spring Boot 默认的日志框架 logback。而博主这次项目的例子是基于上一篇的，工程中有用到了Thymeleaf，而Thymeleaf依赖包含了spring-boot-starter，最终我只要引入Thymeleaf即可。</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZjqj9dDkawCIia1vnictiaiaZS0gr25DOXCiciaQZSxRHpHGB3u773BlJaDzw/0?wx_fmt=jpeg" alt></p>
<p>具体可以看该图</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZLRuq4fUU9bCdcG3bXTpvjxtZqWAicySaXRiaV0S68mNvz1zmXNsDC3fw/0?wx_fmt=jpeg" alt></p>
<p>默认配置属性支持</p>
<p>Spring Boot为我们提供了很多默认的日志配置，所以，只要将spring-boot-starter-logging作为依赖加入到当前应用的classpath，则“开箱即用”。</p>
<p>下面介绍几种在application.properties就可以配置的日志相关属性。</p>
<p>控制台输出</p>
<p>日志级别从低到高分为TRACE &lt; DEBUG &lt; INFO &lt; WARN &lt; ERROR &lt; FATAL，如果设置为WARN，则低于WARN的信息都不会输出。</p>
<p>Spring Boot中默认配置ERROR、WARN和INFO级别的日志输出到控制台。您还可以通过启动您的应用程序–debug标志来启用“调试”模式（开发的时候推荐开启）,以下两种方式皆可：</p>
<ul>
<li><p>在运行命令后加入–debug标志，如：$ java -jar springTest.jar –debug</p>
</li>
<li><p>在application.properties中配置debug=true，该属性置为true的时候，核心Logger（包含嵌入式容器、hibernate、spring）会输出更多内容，但是你自己应用的日志并不会输出为DEBUG级别。</p>
</li>
</ul>
<p>文件输出</p>
<p>默认情况下，Spring Boot将日志输出到控制台，不会写到日志文件。如果要编写除控制台输出之外的日志文件，则需在application.properties中设置logging.file或logging.path属性。</p>
<ul>
<li><p>logging.file，设置文件，可以是绝对路径，也可以是相对路径。如：logging.file=my.log</p>
</li>
<li><p>logging.path，设置目录，会在该目录下创建spring.log文件，并写入日志内容，如：logging.path=/var/log</p>
</li>
</ul>
<p>如果只配置 logging.file，会在项目的当前路径下生成一个 xxx.log 日志文件。</p>
<p>如果只配置 logging.path，在 /var/log文件夹生成一个日志文件为 spring.log</p>
<p>注：二者不能同时使用，如若同时使用，则只有logging.file生效</p>
<p>默认情况下，日志文件的大小达到10MB时会切分一次，产生新的日志文件，默认级别为：ERROR、WARN、INFO</p>
<h1 id="级别控制"><a href="#级别控制" class="headerlink" title="级别控制"></a>级别控制</h1><p>所有支持的日志记录系统都可以在Spring环境中设置记录级别（例如在application.properties中）</p>
<p>格式为：’logging.level.* = LEVEL’</p>
<ul>
<li><p>logging.level：日志级别控制前缀，*为包名或Logger名</p>
</li>
<li><p>LEVEL：选项TRACE, DEBUG, INFO, WARN, ERROR, FATAL, OFF</p>
</li>
</ul>
<p>举例：</p>
<ul>
<li><p>logging.level.com.dudu=DEBUG：com.dudu包下所有class以DEBUG级别输出</p>
</li>
<li><p>logging.level.root=WARN：root日志以WARN级别输出</p>
</li>
</ul>
<h1 id="自定义日志配置"><a href="#自定义日志配置" class="headerlink" title="自定义日志配置"></a>自定义日志配置</h1><p>由于日志服务一般都在ApplicationContext创建前就初始化了，它并不是必须通过Spring的配置文件控制。因此通过系统属性和传统的Spring Boot外部配置文件依然可以很好的支持日志控制和管理。</p>
<p>根据不同的日志系统，你可以按如下规则组织配置文件名，就能被正确加载：</p>
<ul>
<li><p>Logback：logback-spring.xml, logback-spring.groovy, logback.xml, logback.groovy</p>
</li>
<li><p>Log4j：log4j-spring.properties, log4j-spring.xml, log4j.properties, log4j.xml</p>
</li>
<li><p>Log4j2：log4j2-spring.xml, log4j2.xml</p>
</li>
<li><p>JDK (Java Util Logging)：logging.properties</p>
</li>
</ul>
<p>Spring Boot官方推荐优先使用带有-spring的文件名作为你的日志配置（如使用logback-spring.xml，而不是logback.xml），命名为logback-spring.xml的日志配置文件，spring boot可以为它添加一些spring boot特有的配置项（下面会提到）。</p>
<p>上面是默认的命名规则，并且放在src/main/resources下面即可。</p>
<p>如果你即想完全掌控日志配置，但又不想用logback.xml作为Logback配置的名字，可以通过logging.config属性指定自定义的名字：</p>
<p>logging.config=classpath:logging-config.xml</p>
<p>虽然一般并不需要改变配置文件的名字，但是如果你想针对不同运行时Profile使用不同的日</p>
<p>志配置，这个功能会很有用。</p>
<p>下面我们来看看一个普通的logback-spring.xml例子</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZ8C4pT5iaWm1pS3O6lCxFeCw3CYfibdrpc1FS3OsmribWGrwg2Y0LlREWA/0?wx_fmt=jpeg" alt></p>
<h1 id="根节点包含的属性"><a href="#根节点包含的属性" class="headerlink" title="根节点包含的属性"></a>根节点<configuration>包含的属性</configuration></h1><ul>
<li><p>scan:当此属性设置为true时，配置文件如果发生改变，将会被重新加载，默认值为true。</p>
</li>
<li><p>scanPeriod:设置监测配置文件是否有修改的时间间隔，如果没有给出时间单位，默认单位是毫秒。当scan为true时，此属性生效。默认的时间间隔为1分钟。</p>
</li>
<li><p>debug:当此属性设置为true时，将打印出logback内部日志信息，实时查看logback运行状态。默认值为false。</p>
</li>
</ul>
<p>根节点<configuration>的子节点：</configuration></p>
<p><configuration>下面一共有2个属性，3个子节点，分别是：</configuration></p>
<h1 id="属性一：设置上下文名称"><a href="#属性一：设置上下文名称" class="headerlink" title="属性一：设置上下文名称"></a>属性一：设置上下文名称<contextname></contextname></h1><p>每个logger都关联到logger上下文，默认上下文名称为“default”。但可以使用<contextname>设置成其他名字，用于区分不同应用程序的记录。一旦设置，不能修改,可以通过%contextName来打印日志上下文名称。</contextname></p>
<contextname>logback</contextname>

<h1 id="属性二：设置变量"><a href="#属性二：设置变量" class="headerlink" title="属性二：设置变量"></a>属性二：设置变量<property></property></h1><p>用来定义变量值的标签，<property> 有两个属性，name和value；其中name的值是变量的名称，value的值时变量定义的值。通过<property>定义的值会被插入到logger上下文中。定义变量后，可以使“${}”来使用变量。</property></property></p>
<property name="log.path" value="E:\\logback.log">

<h1 id="子节点一"><a href="#子节点一" class="headerlink" title="子节点一"></a>子节点一<appender></appender></h1><p>appender用来格式化日志输出节点，有俩个属性name和class，class用来指定哪种输出策略，常用就是控制台输出策略和文件输出策略。</p>
<h1 id="控制台输出ConsoleAppender："><a href="#控制台输出ConsoleAppender：" class="headerlink" title="控制台输出ConsoleAppender："></a>控制台输出ConsoleAppender：</h1><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZoW2jBVEN4vIcQKoJlzCibH4B3O6BkYzbiaOKY3EeKPmpNticnc8UK3YXQ/0?wx_fmt=jpeg" alt></p>
<p><encoder>表示对日志进行编码：</encoder></p>
<ul>
<li><p>%d{HH: mm:ss.SSS}——日志输出时间</p>
</li>
<li><p>%thread——输出日志的进程名字，这在Web应用以及异步任务处理中很有用</p>
</li>
<li><p>%-5level——日志级别，并且使用5个字符靠左对齐</p>
</li>
<li><p>%logger{36}——日志输出者的名字</p>
</li>
<li><p>%msg——日志消息</p>
</li>
<li><p>%n——平台的换行符</p>
</li>
</ul>
<p>ThresholdFilter为系统定义的拦截器，例如我们用ThresholdFilter来过滤掉ERROR级别以下的日志不输出到文件中。如果不用记得注释掉，不然你控制台会发现没日志~</p>
<h1 id="输出到文件RollingFileAppender"><a href="#输出到文件RollingFileAppender" class="headerlink" title="输出到文件RollingFileAppender"></a>输出到文件RollingFileAppender</h1><p>另一种常见的日志输出到文件，随着应用的运行时间越来越长，日志也会增长的越来越多，将他们输出到同一个文件并非一个好办法。RollingFileAppender用于切分文件日志：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZYC8gtMibGPxwvtZgadap07IslYl68RsZuLMoDSoiaFtgqNRBicLwyibbeA/0?wx_fmt=jpeg" alt></p>
<p>其中重要的是rollingPolicy的定义，上例中<filenamepattern>logback.%d{yyyy-MM-dd}.log</filenamepattern>定义了日志的切分方式——把每一天的日志归档到一个文件中，<maxhistory>30</maxhistory>表示只保留最近30天的日志，以防止日志填满整个磁盘空间。同理，可以使用%d{yyyy-MM-dd_HH-mm}来定义精确到分的日志切分方式。<totalsizecap>1GB</totalsizecap>用来指定日志文件的上限大小，例如设置为1GB的话，那么到了这个值，就会删除旧的日志。</p>
<h1 id="子节点二"><a href="#子节点二" class="headerlink" title="子节点二"></a>子节点二<root></root></h1><p>root节点是必选节点，用来指定最基础的日志输出级别，只有一个level属性。</p>
<ul>
<li>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，不能设置为INHERITED或者同义词NULL，默认是DEBUG。</li>
</ul>
<p><root>可以包含零个或多个<appender-ref>元素，标识这个appender将会添加到这个loger。</appender-ref></root></p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZTEpw90TPC5WTQWbS1J9OGvL5uo2jeqOHh3Xs1MrETIupxHr3psZibqA/0?wx_fmt=jpeg" alt></p>
<h1 id="子节点三"><a href="#子节点三" class="headerlink" title="子节点三"></a>子节点三<loger></loger></h1><p><loger>用来设置某一个包或者具体的某一个类的日志打印级别、以及指定<appender>。<loger>仅有一个name属性，一个可选的level和一个可选的addtivity属性。</loger></appender></loger></p>
<ul>
<li><p>name:用来指定受此loger约束的某一个包或者具体的某一个类。</p>
</li>
<li><p>level:用来设置打印级别，大小写无关：TRACE, DEBUG, INFO, WARN, ERROR, ALL 和 OFF，还有一个特俗值INHERITED或者同义词NULL，代表强制执行上级的级别。如果未设置此属性，那么当前loger将会继承上级的级别。</p>
</li>
<li><p>addtivity:是否向上级loger传递打印信息。默认是true。</p>
</li>
</ul>
<p>loger在实际使用的时候有两种情况，先来看一看代码中如何使用：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZAzCSmgKUQA7ASFdOs4M9Zlk32sdRotDyXjGzlPWlgpom6nNrgrddbg/0?wx_fmt=jpeg" alt></p>
<p>这是一个登录的判断的方法，我们引入日志，并且打印不同级别的日志，然后根据logback-spring.xml中的配置来看看打印了哪几种级别日志。</p>
<h1 id="第一种：带有loger的配置，不指定级别，不指定appender"><a href="#第一种：带有loger的配置，不指定级别，不指定appender" class="headerlink" title="第一种：带有loger的配置，不指定级别，不指定appender"></a>第一种：带有loger的配置，不指定级别，不指定appender</h1><logger name="com.dudu.controller">

<p><logger name="com.dudu.controller">将控制controller包下的所有类的日志的打印，但是并没用设置打印级别，所以继承他的上级<root>的日志级别“info”；</root></logger></p>
<p>没有设置addtivity，默认为true，将此loger的打印信息向上级传递；</p>
<p>没有设置appender，此loger本身不打印任何信息。</p>
<p><root level="info">将root的打印级别设置为“info”，指定了名字为“console”的appender。</root></p>
<p>当执行com.dudu.controller.LearnController类的login方法时，LearnController 在包com.dudu.controller中，所以首先执行<logger name="com.dudu.controller">，将级别为“info”及大于“info”的日志信息传递给root，本身并不打印；</logger></p>
<p>root接到下级传递的信息，交给已经配置好的名为“console”的appender处理，“console”appender将信息打印到控制台；</p>
<p>打印结果如下：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZib6J613BiaF2nILuPgEQS1s0GChHaLMB2xNUeu6D5ORNonTONibJ0qEHQ/0?wx_fmt=jpeg" alt></p>
<h1 id="第二种：带有多个loger的配置，指定级别，指定appender"><a href="#第二种：带有多个loger的配置，指定级别，指定appender" class="headerlink" title="第二种：带有多个loger的配置，指定级别，指定appender"></a>第二种：带有多个loger的配置，指定级别，指定appender</h1><p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZ6cGxzz7IRhYQ6a6ibIT43twjwtiarEicyQqXYLIP0RnAdEIQ9V3u9rTCg/0?wx_fmt=jpeg" alt></p>
<p>控制com.dudu.controller.LearnController类的日志打印，打印级别为“WARN”</p>
<p>additivity属性为false，表示此loger的打印信息不再向上级传递</p>
<p>指定了名字为“console”的appender</p>
<p>这时候执行com.dudu.controller.LearnController类的login方法时，先执行<logger name="com.dudu.controller.LearnController" level="WARN" additivity="false">,</logger></p>
<p>将级别为“WARN”及大于“WARN”的日志信息交给此loger指定的名为“console”的appender处理，在控制台中打出日志，不再向上级root传递打印信息。</p>
<p>打印结果如下：</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZ4kphsxsia6RLxPWfAKtFkDcdv7U6r44OZsERib7JK9B9pawyU7BYY0aQ/0?wx_fmt=jpeg" alt></p>
<p>当然如果你把additivity=”false”改成additivity=”true”的话，就会打印两次，因为打印信息向上级传递，logger本身打印一次，root接到后又打印一次。</p>
<h1 id="多环境日志输出"><a href="#多环境日志输出" class="headerlink" title="多环境日志输出"></a>多环境日志输出</h1><p>据不同环境（prod:生产环境，test:测试环境，dev:开发环境）来定义不同的日志输出，在 logback-spring.xml中使用 springProfile 节点来定义，方法如下：</p>
<p>文件名称不是logback.xml，想使用spring扩展profile支持，要以logback-spring.xml命名</p>
<p><img src="http://mmbiz.qpic.cn/mmbiz_jpg/pcT41pYWuUGIFq5OADicTfIXZlkBfA7GZyekz9vtUPp2qVwibr22CqF737hFvhyV6wv1SgXWbg6NkKicJdA8mJQYg/0?wx_fmt=jpeg" alt></p>
<p>可以启动服务的时候指定 profile （如不指定使用默认），如指定prod 的方式为：</p>
<p>java -jar xxx.jar –spring.profiles.active=prod</p>
<p>关于多环境配置可以参考</p>
<p>Spring Boot干货系列：（二）配置文件解析</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到此为止终于介绍完日志框架了，平时使用的时候推荐用自定义logback-spring.xml来配置，代码中使用日志也很简单，类里面添加private Logger logger = LoggerFactory.getLogger(this.getClass());即可。</p>
</logger></property>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/15/springboot日志框架/" data-id="cjyvgp28h001iswurhowkug85" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-0415" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/15/0415/" class="article-date">
  <time datetime="2019-04-15T10:53:08.000Z" itemprop="datePublished">2019-04-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/15/0415/">总结0415</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>git reset (–mixed) HEAD~1<br>回退一个版本,且会将暂存区的内容和本地已提交的内容全部恢复到未暂存的状态,不影响原来本地文件(未提交的也<br>不受影响)<br>git reset –soft HEAD~1<br>回退一个版本,不清空暂存区,将已提交的内容恢复到暂存区,不影响原来本地的文件(未提交的也不受影响)<br>git reset –hard HEAD~1<br>回退一个版本,清空暂存区,将已提交的内容的版本恢复到本地,本地的文件也将被恢复的版本替换</p>
<p>git stash<br>git stash pop<br>git stash list</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/15/0415/" data-id="cjyvgp26m0005swurfbzgxqir" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-1904" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/1904/" class="article-date">
  <time datetime="2019-04-10T15:40:16.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/1904/">1904广告需求</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>推广<br>搜狗 <a href="http://apihome.sogou.com/document/ss/doc1-1.jsp" target="_blank" rel="noopener">http://apihome.sogou.com/document/ss/doc1-1.jsp</a><br>360 <a href="http://open.e.360.cn/api/report_queryword.html" target="_blank" rel="noopener">http://open.e.360.cn/api/report_queryword.html</a><br>百度 <a href="http://dev2.baidu.com/newdev2/dist/index.html#/content/?pageType=1&amp;productlineId=3&amp;nodeId=128&amp;pageId=37&amp;url=" target="_blank" rel="noopener">http://dev2.baidu.com/newdev2/dist/index.html#/content/?pageType=1&amp;productlineId=3&amp;nodeId=128&amp;pageId=37&amp;url=</a></p>
<p>计划/单元/关键词/创意/搜索词  展现，点击，消费数据，<br>百度:  提供以上5个维度的实时报告数据<br>360：推广计划报告列表，推广组报告列表， 关键词报告列表，创意报告列表，搜索词报告列表<br>搜狗：实时报告服务 (只能到计划级别)</p>
<p>关键词 出价，匹配方式，PC访问url，移动访问url<br>百度:  BulkJobService<br>360：获取推广计划的完整数据<br>搜狗 ：整账户下载</p>
<p>关键词排名<br>百度:  同展现，点击，消费接口<br>搜狗:   平均排名下载服务（无文档说明）<br>360： 推广实况(没有批量接口)</p>
<p>(待定)搜索词 是否存在账户中，平均排名，是否与关键词一致<br>360：搜索词报告列表是没有排名的<br>百度：搜索词报告中有排名<br>搜狗：没有搜索词</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/10/1904/" data-id="cjyvgp26z000aswurvox66xa6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-0408" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/10/0408/" class="article-date">
  <time datetime="2019-04-10T02:01:16.000Z" itemprop="datePublished">2019-04-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/10/0408/">总结0410</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.gradle 打包：<br><a href="https://www.open-open.com/lib/view/open1447139848053.html" target="_blank" rel="noopener">https://www.open-open.com/lib/view/open1447139848053.html</a></p>
<p><a href="https://my.oschina.net/u/2505383/blog/677301" target="_blank" rel="noopener">https://my.oschina.net/u/2505383/blog/677301</a><br>2.跨域：<br><a href="https://segmentfault.com/a/1190000015597029" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015597029</a></p>
<p>3.@RefreshScope配置热刷新</p>
<p>4.springboot自动配置<br>自动配置原理：利用SpringFactoriesLoader获取META-INF/spring.factories中org.springframework.boot.autoconfigure.EnableAutoConfiguration对应的配置项(com.alibaba.druid.spring.boot.autoconfigure.DruidDataSourceAutoConfigure)，将配置项转换为注解为@Configuration的JavaConfig形式的配置类，汇总为一个加载到IoC容器中。 研究了半天<br><a href="https://www.cnblogs.com/zheting/p/6707035.html" target="_blank" rel="noopener">https://www.cnblogs.com/zheting/p/6707035.html</a></p>
<p>5.git<br>git checkut<br>git reset HEAD<br>git reset<br>git revert<br><a href="https://www.cnblogs.com/ChrisZhou666/p/9310235.html" target="_blank" rel="noopener">https://www.cnblogs.com/ChrisZhou666/p/9310235.html</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/10/0408/" data-id="cjyvgp26q0006swur94x110s5" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-0404" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/04/0404/" class="article-date">
  <time datetime="2019-04-03T16:02:16.000Z" itemprop="datePublished">2019-04-04</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/04/0404/">总结0404</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>1.linkflow其他channel相关<br>2.Websocket<br>3.gateway<br>4.config</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/04/0404/" data-id="cjyvgp26w0008swur6q1p3wq6" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-jinshuju流程" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/03/jinshuju流程/" class="article-date">
  <time datetime="2019-04-03T15:40:16.000Z" itemprop="datePublished">2019-04-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/03/jinshuju流程/">总结0403(金数据linkflow分析)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="1-connect"><a href="#1-connect" class="headerlink" title="1.connect"></a>1.connect</h3><p>1.1根据code和state获取token,得到token,refresh_token,和期限等信息-&gt;用accesstoken获取profile<br>1.2将email作为channelId,查数据库是否已存在channeldto<br>不存在则重新构建channeldto和channedto.property<br>1.3事务执行channeldto插入数据库，同时将access_token和refresh_token插入redis,accesstoken设置redis过期时间</p>
<h3 id="2-getaccesstoken根据channelId"><a href="#2-getaccesstoken根据channelId" class="headerlink" title="2.getaccesstoken根据channelId"></a>2.getaccesstoken根据channelId</h3><p>从redis获取accesstoken如果为空，则获取refreshtoken,并从新请求获取token信息，并设置进入redis(refreshToken每次都更新进channel.property的数据库字段中)</p>
<h3 id="3-handleSubmit-String-channelId-JsonNode-responseBody"><a href="#3-handleSubmit-String-channelId-JsonNode-responseBody" class="headerlink" title="3.handleSubmit(String channelId, JsonNode responseBody)"></a>3.handleSubmit(String channelId, JsonNode responseBody)</h3><p>1.根据JinshujuSubmitDTO获取FormMappingDTO<br>2.判断是否是微信过来的用户，曾经关注过的用户取出contact; 未关注过的新建用户创建匿名用户<br>3.既是匿名用户又没有表单映射，退出<br>匿名访问情况下先通过表单的值查询是否有已存在用户（通过邮箱和手机号）<br>4.根据channeldto和submitdto创建EventDTO<br>5.用channelId和contactDTO调用<br>==contactFacade.save==：<br>保存contactDTO，更新渠道账号信息ContactIdentityDTO<br>循环获取contactdto的event,调用：<br>==eventService.create(eventDTO)==：<br>保存event，循环子事件，调用rabbitMq消息</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/03/jinshuju流程/" data-id="cjyvgp27l000yswur9tfx0f0a" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">&laquo; Prev</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/page/7/">7</a><a class="extend next" rel="next" href="/page/4/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/03/0707-md/">0707.md</a>
          </li>
        
          <li>
            <a href="/2019/06/16/Collectors-toMap的问题/">Collectors.toMap的问题</a>
          </li>
        
          <li>
            <a href="/2019/06/16/hystrix请求命令/">hystrix请求命令</a>
          </li>
        
          <li>
            <a href="/2019/06/16/cas单点登陆/">cas单点登陆</a>
          </li>
        
          <li>
            <a href="/2019/06/16/paxos算法/">paxos算法</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Zavier<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
    <a href="/technology" class="mobile-nav-link">Technology</a>
  
    <a href="/about" class="mobile-nav-link">About</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>